%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{risk\_dash Documentation}
\date{Apr 20, 2021}
\release{0.0.2}
\author{Alexander van Oene}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{risk\_dash}
\label{\detokenize{readme:risk-dash}}\label{\detokenize{readme::doc}}
\sphinxAtStartPar
\sphinxhref{https://github.com/avanoene/risk\_dash}{risk\_dash} is a framework to
help simplify the data flow for a portfolio of assets and handle market
risk metrics at the asset and portfolio level. If you clone the source
\sphinxhref{https://github.com/avanoene/risk\_dash}{repository}, included is a
\sphinxhref{https://plot.ly/dash/}{Dash} application to be an example of some of
the uses for the package.


\section{Disclaimer: Due to data issues, only up to March 28th EOD is available from Quandl’s WIKI EOD Stock Prices found in the example application.}
\label{\detokenize{readme:disclaimer-due-to-data-issues-only-up-to-march-28th-eod-is-available-from-quandls-wiki-eod-stock-prices-found-in-the-example-application}}

\subsection{Abstract}
\label{\detokenize{readme:abstract}}
\sphinxAtStartPar
While there are many Python packages that provide ways to do data
analysis, in fact the package utilizes
\sphinxhref{https://pandas.pydata.org/}{pandas},
\sphinxhref{http://www.numpy.org/}{numpy}, and
\sphinxhref{https://www.scipy.org/}{scipy} heavily, there are few that apply and
handle common tasks that analysts face in quantifying market risk.
\sphinxhref{https://github.com/quantopian/pyfolio}{pyfolio} is one of those
packages, however it forces you to utilize their infrastructure package
\sphinxhref{http://www.zipline.io/}{Zipline} where as
\sphinxhref{https://github.com/avanoene/risk\_dash}{risk\_dash} aims to provide a
framework to formalize the data flow while being totally customizable
for the analyst. \sphinxhref{https://github.com/avanoene/risk\_dash}{risk\_dash}
is comprised of classes and methods to handle the data flow and
calculation of market risk metrics at the asset and portfolio level. In
use, this package should ease the developer’s work in building a
comprehensive risk analytics application and specifying the underlying
risk distribution. This package does not aim to generate trade ideas,
but quantify the market risks portfolios of securities face. Included is
an example of an application that utilizes this framework focusing on an
equity portfolio.


\subsection{Thesis Steps}
\label{\detokenize{readme:thesis-steps}}
\sphinxAtStartPar
First create a framework package, risk\_dash, to handle a portfolio of
assets, then create a risk application to calculate and display common
risk factors and metrics to present common uses for the framework,
including: Value at Risk, Expected Portfolio Return and Volatility,
Current Return, Systematic risk (Fama \sphinxhyphen{} French / CAPM)

\sphinxAtStartPar
To accomplish this task, I am planning on using current research and
python packages. I am planning on using \sphinxhref{https://plot.ly/dash/}{Dash by
Plotly} to create the front end user interface
and deploying the underlying Flask app on either
\sphinxhref{https://www.digitalocean.com/}{DigitalOcean} or
\sphinxhref{https://www.heroku.com/}{Heroku}

\sphinxAtStartPar
The object model is housed in \sphinxcode{\sphinxupquote{\textasciitilde{}/risk\_dash/}} where as the application
pages are in \sphinxcode{\sphinxupquote{\textasciitilde{}/pages/}} and are managed by \sphinxcode{\sphinxupquote{/dashapp.py}}

\sphinxAtStartPar
While risk\_dash only needs a few
dependencies,\sphinxhref{https://pandas.pydata.org/}{pandas},
\sphinxhref{http://www.numpy.org/}{numpy},
\sphinxhref{https://www.scipy.org/}{scipy},\sphinxhref{https://www.quandl.com/tools/python}{quandl},
and \sphinxhref{http://docs.python-requests.org/en/master/}{requests}, the
included application uses the dependencies listed in
\sphinxhref{https://github.com/avanoene/risk\_dash/requirements.txt}{requirements.txt}
which can be installed by:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pip install \sphinxhyphen{}r requirements.txt}}

\sphinxAtStartPar
It is highly recommended that you should use a virtual environment when
running the package, for details check the \sphinxhref{https://docs.python.org/3/tutorial/venv.html}{Python
documentation}


\section{Getting Started \sphinxhyphen{} Locally Running the Dash App}
\label{\detokenize{readme:getting-started-locally-running-the-dash-app}}
\sphinxAtStartPar
First add file \sphinxcode{\sphinxupquote{apiconfig.py}} to the directory at the same level as
\sphinxcode{\sphinxupquote{dashapp.py}}. That file should contain all of the api information to
source the market data. I’m using \sphinxhref{https://www.quandl.com/}{Quandl}
so my \sphinxcode{\sphinxupquote{apiconfig.py}} file is the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python3}
\PYG{c+c1}{\PYGZsh{} \PYGZhy{}*\PYGZhy{} coding: utf\PYGZhy{}8 \PYGZhy{}*\PYGZhy{}}

\PYG{n}{quandl\PYGZus{}apikey} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quandl\PYGZhy{}api\PYGZhy{}key}\PYG{l+s+s1}{\PYGZsq{}} \PYG{c+c1}{\PYGZsh{} replace with valid key}
\end{sphinxVerbatim}

\sphinxAtStartPar
To use a different market data source, first write a specific
\sphinxcode{\sphinxupquote{MarketData}} class in \sphinxcode{\sphinxupquote{market\_data.py}}

\sphinxAtStartPar
To run the server locally using the underlying Flask Server, run the
following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{dashapp}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you wanted to use \sphinxcode{\sphinxupquote{gunicorn}} to run the server, you would just run
\sphinxcode{\sphinxupquote{gunicorn dashapp:server}} from the command line.


\section{Documentation}
\label{\detokenize{readme:documentation}}
\sphinxAtStartPar
Hosted documentation is coming soon. Below is a high level overview of
the project:


\subsection{Object Model}
\label{\detokenize{readme:object-model}}
\sphinxAtStartPar
The framework seeks to address a solution to the data pipeline, since
the scale is manageable within memory at the moment, that pipeline
includes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Gathering required data from source systems, i.e. market data,
portfolio data, security data

\item {} 
\sphinxAtStartPar
Managing that data, potentially storing as scale increases

\item {} 
\sphinxAtStartPar
Manipulating to create new data

\item {} 
\sphinxAtStartPar
Returning or storing results

\end{itemize}

\sphinxAtStartPar
To handle that pipeline, the current model is:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Portfolio
\begin{itemize}
\item {} 
\sphinxAtStartPar
Security

\end{itemize}

\item {} 
\sphinxAtStartPar
SimulationGenerator

\item {} 
\sphinxAtStartPar
MarketData

\item {} 
\sphinxAtStartPar
FundamentalData (Not implemented)

\end{itemize}

\sphinxAtStartPar
MarketData objects should be the source of the data for a particular
Security (or underlier if a derivative security), attributes: \sphinxhyphen{} Prices \sphinxhyphen{}
Source engine (where the data comes from) \sphinxhyphen{} Common metrics (first
integrated series ‘daily price change’, shape, dispersion)

\sphinxAtStartPar
SimulationGenerator objects should dictate how any simulation should be
conducted, attributes: \sphinxhyphen{} Transformation methods \sphinxhyphen{} Number of observations
\sphinxhyphen{} Lookback period, if necessary

\sphinxAtStartPar
Security objects could be any asset, those assets have: \sphinxhyphen{} Identification
data: Ticker, CUSIP, Exchange \sphinxhyphen{} Security specific data: expiry,
valuation functions \sphinxhyphen{} Market data: Closing prices, YTM \sphinxhyphen{} Risk Attributes

\sphinxAtStartPar
The Portfolio object as a collection of Security objects and potentially
other Portfolio objects, since we could have different hierarchal
structures within the book \sphinxhyphen{} This then should house the VCV and common
historic market data


\subsection{File Structure}
\label{\detokenize{readme:file-structure}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{n}{app}\PYG{o}{.}\PYG{n}{py}
\PYG{o}{\PYGZhy{}}\PYG{n}{dashapp}\PYG{o}{.}\PYG{n}{py}
\PYG{o}{\PYGZhy{}}\PYG{n}{pages}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{portfolio\PYGZus{}metrics}\PYG{o}{.}\PYG{n}{py}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{single\PYGZus{}ticker}\PYG{o}{.}\PYG{n}{py}
\PYG{o}{\PYGZhy{}}\PYG{n}{objects}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{securities}\PYG{o}{.}\PYG{n}{py}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{simgen}\PYG{o}{.}\PYG{n}{py}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{market\PYGZus{}data}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}


\subsection{Current App Features}
\label{\detokenize{readme:current-app-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Query an individual stock
\begin{itemize}
\item {} 
\sphinxAtStartPar
See the past 5 YR candlestick chart

\item {} 
\sphinxAtStartPar
See a Monte Carlo simulated vs Historic price distribution

\item {} 
\sphinxAtStartPar
View distribution stats
\begin{itemize}
\item {} 
\sphinxAtStartPar
Value at Risk for individual stock

\item {} 
\sphinxAtStartPar
Annualized vol

\item {} 
\sphinxAtStartPar
Annualized Expected Return

\item {} 
\sphinxAtStartPar
Simply Weighted/ Exponentially Weighted

\end{itemize}

\item {} 
\sphinxAtStartPar
Variable lookback period

\item {} 
\sphinxAtStartPar
Variable sample size

\end{itemize}

\item {} 
\sphinxAtStartPar
User upload stock portfolio
\begin{itemize}
\item {} 
\sphinxAtStartPar
Mark at current price

\item {} 
\sphinxAtStartPar
Calculate portfolio weights

\end{itemize}

\end{itemize}


\subsection{Future App/Package Features}
\label{\detokenize{readme:future-app-package-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Expected Return / Variance / Distribution

\item {} 
\sphinxAtStartPar
Beta to selected market
\begin{itemize}
\item {} 
\sphinxAtStartPar
S\&P 500

\item {} 
\sphinxAtStartPar
Russel 5000

\item {} 
\sphinxAtStartPar
Selected ETF

\end{itemize}

\item {} 
\sphinxAtStartPar
User selection of MonteCarlo Method

\item {} 
\sphinxAtStartPar
Option Pricing for individual stock

\item {} 
\sphinxAtStartPar
Forward looking PDF for Portfolio returns
\begin{itemize}
\item {} 
\sphinxAtStartPar
Bayesian modeling

\item {} 
\sphinxAtStartPar
ARIMA

\end{itemize}

\item {} 
\sphinxAtStartPar
Backtesting tool \sphinxhyphen{} common trading strategies
\begin{itemize}
\item {} 
\sphinxAtStartPar
“Buy and Hold”

\end{itemize}

\end{itemize}


\section{License}
\label{\detokenize{readme:license}}
\sphinxAtStartPar
This project is licensed under the the MIT License \sphinxhyphen{} see the LICENSE.md
file for details


\chapter{risk\_dash Overview and Getting Started}
\label{\detokenize{gettingstarted:risk-dash-overview-and-getting-started}}\label{\detokenize{gettingstarted:gettingstarted}}\label{\detokenize{gettingstarted::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:risk_dash-overview-and-getting-started}]{\emph{risk\_dash Overview and Getting
Started}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:overview}]{\emph{Overview}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:installation}]{\emph{Installation}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:getting-started}]{\emph{Getting Started}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:security-data-security-objects-and-creating-security-subclasses}]{\emph{Security data, Security objects, and creating Security
Subclasses}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:portfolio-data-and-creating-a-portfolio}]{\emph{Portfolio Data and creating a
Portfolio}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:calculating-risk-metrics-and-using-the-portfolio-class}]{\emph{Calculating Risk Metrics and Using the Portfolio
class}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:marking-the-portfolio}]{\emph{Marking the Portfolio}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:parametrically-calculating-the-value-at-risk}]{\emph{Parametrically Calculating the Value at
Risk}}}

\end{itemize}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:simulating-the-portfolio}]{\emph{Simulating the Portfolio}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:simulating-a-unit-resolution-distribution}]{\emph{Simulating a Unit Resolution
Distribution}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:simulating-a-path-distribution}]{\emph{Simulating a Path
Distribution}}}

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{gettingstarted:summary}]{\emph{Summary}}}

\end{itemize}

\end{itemize}


\section{Overview}
\label{\detokenize{gettingstarted:overview}}
\sphinxAtStartPar
\sphinxhref{https://github.com/avanoene/risk\_dash}{risk\_dash} is a framework to
help formalize the data flow for a portfolio of assets and handle market
risk metrics at the asset and portfolio level. If you clone the source
\sphinxhref{https://github.com/avanoene/risk\_dash}{repository}, included is a
\sphinxhref{https://plot.ly/dash/}{Dash} application to be an example of some of
the uses for the package. To run the Dash app, documentation is
\sphinxhref{dashapp\_documentation.rst\#risk\_dash-dash-application-documentation}{here}


\section{Installation}
\label{\detokenize{gettingstarted:installation}}
\sphinxAtStartPar
Since the package is in heavy development, to install the package fork
or clone the \sphinxhref{https://github.com/avanoene/risk\_dash}{repository} and
run \sphinxcode{\sphinxupquote{pip install \sphinxhyphen{}e risk\_dash/}} from the directory above your local
repository.

\sphinxAtStartPar
To see if installation was successful run
\sphinxcode{\sphinxupquote{python \sphinxhyphen{}c \textquotesingle{}import risk\_dash; print(*dir(risk\_dash), sep="\textbackslash{}n")\textquotesingle{}}} in
the command line, currently the output should match the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python \PYGZhy{}c \PYG{l+s+s1}{\PYGZsq{}import risk\PYGZus{}dash; print(*dir(risk\PYGZus{}dash), sep=\PYGZdq{}\PYGZbs{}n\PYGZdq{})\PYGZsq{}}
\PYGZus{}\PYGZus{}builtins\PYGZus{}\PYGZus{}
\PYGZus{}\PYGZus{}cached\PYGZus{}\PYGZus{}
\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}
\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}
\PYGZus{}\PYGZus{}loader\PYGZus{}\PYGZus{}
\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}
\PYGZus{}\PYGZus{}package\PYGZus{}\PYGZus{}
\PYGZus{}\PYGZus{}path\PYGZus{}\PYGZus{}
\PYGZus{}\PYGZus{}spec\PYGZus{}\PYGZus{}
market\PYGZus{}data
name
securities
simgen
\end{sphinxVerbatim}


\section{Getting Started}
\label{\detokenize{gettingstarted:getting-started}}
\sphinxAtStartPar
Now that we have the package installed, let’s go through the object
workflow to construct a simple long/short equity portfolio.

\sphinxAtStartPar
From a high level, we need to specify:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Portfolio Data
\begin{itemize}
\item {} 
\sphinxAtStartPar
We need to know what’s in the portfolio
\begin{itemize}
\item {} 
\sphinxAtStartPar
Portfolio weights

\item {} 
\sphinxAtStartPar
Types of Assets/Securities

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
Security data
\begin{itemize}
\item {} 
\sphinxAtStartPar
We need to know what is important to financially model the
security
\begin{itemize}
\item {} 
\sphinxAtStartPar
Identification data: Ticker, CUSIP, Exchange

\item {} 
\sphinxAtStartPar
Security specific data: expiry, valuation functions

\item {} 
\sphinxAtStartPar
Market data: Closing prices, YTM

\end{itemize}

\end{itemize}

\item {} 
\sphinxAtStartPar
Portfolio/security constructors to handle the above data

\end{enumerate}

\sphinxAtStartPar
To visualize these constructors, the below chart shows how the data will
sit:

\sphinxAtStartPar
\sphinxincludegraphics{{888fc6e8946d292e4b19c90c5363d12c43a2649e}.png}

\sphinxAtStartPar
To do so, we’ll need subclasses for the \sphinxcode{\sphinxupquote{\_Security}} and
\sphinxcode{\sphinxupquote{\_MarketData}} classes to model specific types of securities. Currently
supported is the Equity subclass. Once we have the portfolio
constructed, we will specify and calculate parameters to simulate or
look at historic distributions. We’ll then create a subclass of
\sphinxcode{\sphinxupquote{\_Simulation}} and \sphinxcode{\sphinxupquote{\_RandomGen}}.


\subsection{Security data, Security objects, and creating Security Subclasses}
\label{\detokenize{gettingstarted:security-data-security-objects-and-creating-security-subclasses}}
\sphinxAtStartPar
The core of the package is in the \sphinxcode{\sphinxupquote{\_Security}} and \sphinxcode{\sphinxupquote{Portfolio}}
objects. \sphinxcode{\sphinxupquote{Portfolio}} objects are naturally a collection of Securities,
however we want to specify the type of securities that are in the
portfolio. Since we’re focusing on a long/short equity portfolio we want
to create an Equity subclass.

\sphinxAtStartPar
Subclasses of \sphinxcode{\sphinxupquote{\_Security}} classes must have the following methods:
\begin{itemize}
\item {} 
\sphinxAtStartPar
valuation(current\_price)

\item {} 
\sphinxAtStartPar
mark\_to\_market(current\_price)

\item {} 
\sphinxAtStartPar
get\_marketdata()

\end{itemize}

\sphinxAtStartPar
In addition, we want to pass them the associated \sphinxcode{\sphinxupquote{\_MarketData}} object
to represent the security’s historic pricing data. To build the
\sphinxcode{\sphinxupquote{Equity}} subclass, we first want to inherit any methods from the
\sphinxcode{\sphinxupquote{\_Security}} class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Equity}\PYG{p}{(}\PYG{n}{\PYGZus{}Security}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}
            \PYG{n+nb+bp}{self}\PYG{p}{,}
            \PYG{n}{ticker}\PYG{p}{,}
            \PYG{n}{market\PYGZus{}data} \PYG{p}{:} \PYG{n}{md}\PYG{o}{.}\PYG{n}{QuandlStockData}\PYG{p}{,}
            \PYG{n}{ordered\PYGZus{}price}\PYG{p}{,}
            \PYG{n}{quantity}\PYG{p}{,}
            \PYG{n}{date\PYGZus{}ordered}
        \PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{ticker}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{market\PYGZus{}data} \PYG{o}{=} \PYG{n}{market\PYGZus{}data}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ordered\PYGZus{}price} \PYG{o}{=} \PYG{n}{ordered\PYGZus{}price}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{quantity} \PYG{o}{=} \PYG{n}{quantity}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{initial\PYGZus{}value} \PYG{o}{=} \PYG{n}{ordered\PYGZus{}price} \PYG{o}{*} \PYG{n}{quantity}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{date\PYGZus{}ordered} \PYG{o}{=} \PYG{n}{date\PYGZus{}ordered}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Equity}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
To break down the inputs, we want to keep in mind that the goal of this
subclass of the \sphinxcode{\sphinxupquote{\_Security}} object is to provide an interface to model
the Equity data.
\begin{itemize}
\item {} 
\sphinxAtStartPar
ticker is going to be the ticker code for the equity, such as ‘AAPL’

\item {} 
\sphinxAtStartPar
market\_data is going to be a subclass of the \sphinxcode{\sphinxupquote{\_MarketData}} object

\item {} 
\sphinxAtStartPar
ordered\_price is going to be the price which the trade occurred

\item {} 
\sphinxAtStartPar
quantity for Equity will be the number of shares

\item {} 
\sphinxAtStartPar
date\_ordered should be the date the order was placed

\end{itemize}
\begin{quote}

\sphinxAtStartPar
Note: Currently the implemented \sphinxcode{\sphinxupquote{\_MarketData}} subclass is
\sphinxcode{\sphinxupquote{QuandlStockData}}, which is a wrapper for \sphinxhref{https://www.quandl.com/databases/WIKIP}{this Quandl dataset
api}. This data is no
longer being updated, for current market prices you must create a
\_MarketData subclass for your particular market data.
\end{quote}

\sphinxAtStartPar
Required Inputs at the \sphinxcode{\sphinxupquote{\_Security}} level are intentionally limited,
for example if we wanted to create a class for Fixed Income securities,
we would want more information than this Equity subclass. An example
Bond class might look like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Bond}\PYG{p}{(}\PYG{n}{\PYGZus{}Security}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}
            \PYG{n+nb+bp}{self}\PYG{p}{,}
            \PYG{n}{CUSIP}\PYG{p}{,}
            \PYG{n}{market\PYGZus{}data}\PYG{p}{,}
            \PYG{n}{expiry}\PYG{p}{,}
            \PYG{n}{coupon}\PYG{p}{,}
            \PYG{n}{frequency}\PYG{p}{,}
            \PYG{n}{settlement\PYGZus{}date}\PYG{p}{,}
            \PYG{n}{face\PYGZus{}value}
        \PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{CUSIP}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{market\PYGZus{}data} \PYG{o}{=} \PYG{n}{market\PYGZus{}data}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{expiry} \PYG{o}{=} \PYG{n}{expiry}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{coupon} \PYG{o}{=} \PYG{n}{coupon}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{frequency} \PYG{o}{=} \PYG{n}{frequency}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{settlement\PYGZus{}date} \PYG{o}{=} \PYG{n}{settlement\PYGZus{}date}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{face\PYGZus{}value} \PYG{o}{=} \PYG{n}{face\PYGZus{}value}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{type} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Bond}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Similarly to the \sphinxcode{\sphinxupquote{Equity}} subclass, we want identification
information, market data, and arguments that will either help in
calculating valuation, current returns, or risk measures.

\sphinxAtStartPar
Returning to the \sphinxcode{\sphinxupquote{Equity}} subclass, we now need to write the valuation
and mark to market methods:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Equity}\PYG{p}{(}\PYG{n}{\PYGZus{}Security}\PYG{p}{)}\PYG{p}{:}
  \PYG{c+c1}{\PYGZsh{} ...}
  \PYG{k}{def} \PYG{n+nf}{valuation}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{price}\PYG{p}{)}\PYG{p}{:}
      \PYG{n}{value} \PYG{o}{=} \PYG{p}{(}\PYG{n}{price} \PYG{o}{\PYGZhy{}} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ordered\PYGZus{}price}\PYG{p}{)} \PYG{o}{*} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{quantity}
      \PYG{k}{return}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}

  \PYG{k}{def} \PYG{n+nf}{mark\PYGZus{}to\PYGZus{}market}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{current\PYGZus{}price}\PYG{p}{)}\PYG{p}{:}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{market\PYGZus{}value} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{quantity} \PYG{o}{*} \PYG{n}{current\PYGZus{}price}
      \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{marked\PYGZus{}change} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{valuation}\PYG{p}{(}\PYG{n}{current\PYGZus{}price}\PYG{p}{)}
      \PYG{k}{return}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{marked\PYGZus{}change}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For linear instruments such as equities, valuation of a position is just
the price observed minus the price ordered at the size of the position.
The \sphinxcode{\sphinxupquote{valuation}} method is then used to pass a hypothetical price into
the valuation function, in this case (Price \sphinxhyphen{} Ordered) * Quantity,
where as \sphinxcode{\sphinxupquote{mark\_to\_market}} method is used to pass the current EOD price
and mark the value of the position. This is an important distinction, if
we had a nonlinear instrument such as a call option on a company’s
equity price, the valuation function would then be:
\begin{equation*}
\begin{split}Value = min\{0, S_{T} - K\}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(S_{T}\) is the spot price for the equity at expiry and
\(K\) is the strike price of the call option contract. Valuation
also is dependent on time for option data, however if you were to use a
binomial tree to evaluate the option, you would want to use this same
value function and discount the value a each node back to time=0.

\sphinxAtStartPar
Our mark to market then would need to make the distinction between this
valuation and the current market price for the call option. The mark
would then keep track of what the current market value for the option to
keep track of actualized returns.

\sphinxAtStartPar
The final piece to creating the Equity subclass is then to add a
\sphinxcode{\sphinxupquote{get\_marketdata()}}method. Since we just want a copy of the reference
of the \sphinxcode{\sphinxupquote{market\_data}}, we can just inherit the \sphinxcode{\sphinxupquote{get\_marketdata()}}
from the \sphinxcode{\sphinxupquote{\_Security}} parent class.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Equity}} subclass is already implemented in the package, we can
create an instance from \sphinxcode{\sphinxupquote{risk\_dash.securities}}. Let’s make an instance
that represents an order of 50 shares of AAPL, Apple Inc, at close on
March 9th, 2018:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{risk\PYGZus{}dash}\PYG{n+nn}{.}\PYG{n+nn}{market\PYGZus{}data} \PYG{k+kn}{import} \PYG{n}{QuandlStockData}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{risk\PYGZus{}dash}\PYG{n+nn}{.}\PYG{n+nn}{securities} \PYG{k+kn}{import} \PYG{n}{Equity}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{datetime} \PYG{k+kn}{import} \PYG{n}{datetime}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{apikey} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{valid\PYGZhy{}quandl\PYGZhy{}apikey}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}market\PYGZus{}data} \PYG{o}{=} \PYG{n}{QuandlStockData}\PYG{p}{(}
\PYG{g+go}{  apikey = apikey,}
\PYG{g+go}{  ticker = \PYGZsq{}AAPL\PYGZsq{}}
\PYG{g+go}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}stock} \PYG{o}{=} \PYG{n}{Equity}\PYG{p}{(}
\PYG{g+go}{  ticker = \PYGZsq{}AAPL\PYGZsq{},}
\PYG{g+go}{  market\PYGZus{}data = aapl\PYGZus{}market\PYGZus{}data,}
\PYG{g+go}{  ordered\PYGZus{}price = 179.98,}
\PYG{g+go}{  quantity = 50,}
\PYG{g+go}{  date\PYGZus{}ordered = datetime(2018,3,9)}
\PYG{g+go}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}stock}\PYG{o}{.}\PYG{n}{valuation}\PYG{p}{(}\PYG{l+m+mf}{180.98}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} \PYGZdl{}1 increase in value}
\PYG{g+go}{50.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}stock}\PYG{o}{.}\PYG{n}{mark\PYGZus{}to\PYGZus{}market}\PYG{p}{(}\PYG{l+m+mf}{180.98}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Same \PYGZdl{}1 increase}
\PYG{g+go}{50.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}stock}\PYG{o}{.}\PYG{n}{market\PYGZus{}value}
\PYG{g+go}{9049.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}stock}\PYG{o}{.}\PYG{n}{marked\PYGZus{}change}
\PYG{g+go}{50.0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{vars}\PYG{p}{(}\PYG{n}{aapl\PYGZus{}stock}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}name\PYGZsq{}: \PYGZsq{}AAPL\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}market\PYGZus{}data\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.market\PYGZus{}data.QuandlStockData at 0x1147c2668\PYGZgt{},}
\PYG{g+go}{ \PYGZsq{}ordered\PYGZus{}price\PYGZsq{}: 179.98,}
\PYG{g+go}{ \PYGZsq{}quantity\PYGZsq{}: 50,}
\PYG{g+go}{ \PYGZsq{}initial\PYGZus{}value\PYGZsq{}: 8999.0,}
\PYG{g+go}{ \PYGZsq{}date\PYGZus{}ordered\PYGZsq{}: datetime.datetime(2018, 3, 9, 0, 0),}
\PYG{g+go}{ \PYGZsq{}type\PYGZsq{}: \PYGZsq{}Equity\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}market\PYGZus{}value\PYGZsq{}: 9049.0,}
\PYG{g+go}{ \PYGZsq{}marked\PYGZus{}change\PYGZsq{}: 50.0\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
As we can see \sphinxcode{\sphinxupquote{aapl\_stock}} now is a container that we can use to
access it’s attributes at the \sphinxcode{\sphinxupquote{Portfolio}} level.
\begin{quote}

\sphinxAtStartPar
Note: Another important observation is that the \sphinxcode{\sphinxupquote{Equity}} subclass
will only keep a reference to the underlying \sphinxcode{\sphinxupquote{QuandlStockData}},
which will minimize duplication of data. However, at scale, you’d
want minimize price calls to your data source, you could then do one
call at the \sphinxcode{\sphinxupquote{Portfolio}} level then pass a reference to that
market\_data at the individual level. Then your \sphinxcode{\sphinxupquote{Equity}} or other
\sphinxcode{\sphinxupquote{\_Security}} subclasses can share the same \sphinxcode{\sphinxupquote{\_MarketData}}, you
would then just write methods to interact with that data.
\end{quote}

\sphinxAtStartPar
Now that we have a feeling for the \sphinxcode{\sphinxupquote{\_Security}} class, we now want to
build a Portfolio that contains the \sphinxcode{\sphinxupquote{\_Security}} instances.


\subsection{Portfolio Data and creating a Portfolio}
\label{\detokenize{gettingstarted:portfolio-data-and-creating-a-portfolio}}
\sphinxAtStartPar
To iterate on what we said before, an equity position in your portfolio
is represented by the quantity you ordered, the price ordered at, and
when you ordered or settled the position. In this example, we’ll use the
following theoretical portfolio found in \sphinxcode{\sphinxupquote{portfolio\_example.csv}}:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Type
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Ticker
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Ordered Price
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Ordered Date
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Quantity
\\
\hline
\sphinxAtStartPar
Equity
&
\sphinxAtStartPar
AAPL
&
\sphinxAtStartPar
179.98
&
\sphinxAtStartPar
3/9/18
&
\sphinxAtStartPar
50
\\
\hline
\sphinxAtStartPar
Equity
&
\sphinxAtStartPar
AMD
&
\sphinxAtStartPar
11.7
&
\sphinxAtStartPar
3/9/18
&
\sphinxAtStartPar
100
\\
\hline
\sphinxAtStartPar
Equity
&
\sphinxAtStartPar
INTC
&
\sphinxAtStartPar
52.19
&
\sphinxAtStartPar
3/9/18
&
\sphinxAtStartPar
\sphinxhyphen{}50
\\
\hline
\sphinxAtStartPar
Equity
&
\sphinxAtStartPar
GOOG
&
\sphinxAtStartPar
1160.04
&
\sphinxAtStartPar
3/9/18
&
\sphinxAtStartPar
5
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
With this example, the portfolio is static, or just one snap shot of the
weights at a given time. In practice, it might be useful to have
multiple snapshots of your portfolio, one’s portfolio would be changing
as positions enter and leave thus having a time dimensionality. The
Portfolio class could be easily adapted to handle that information to
accurately plot historic performance by remarking through time. This
seems more of an accounting exercise, risk metrics looking forward would
probably still only want to account for the current positions in the
portfolio. Due to this insight, the current Portfolio class only looks
at one snap shot in time.

\sphinxAtStartPar
With a portfolio so small, it is very easily stored in a csv and each
security can store the reference to the underlying market data
independently. As such, there is an included portfolio constructor
method in the portfolio class from csv, \sphinxcode{\sphinxupquote{construct\_portfolio\_csv}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{risk\PYGZus{}dash}\PYG{n+nn}{.}\PYG{n+nn}{securities} \PYG{k+kn}{import} \PYG{n}{Portfolio}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{current\PYGZus{}portfolio} \PYG{o}{=} \PYG{n}{Portfolio}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{port\PYGZus{}dict} \PYG{o}{=} \PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{construct\PYGZus{}portfolio\PYGZus{}csv}\PYG{p}{(}
\PYG{g+go}{  data\PYGZus{}input=\PYGZsq{}portfolio\PYGZus{}example.csv\PYGZsq{},}
\PYG{g+go}{  apikey=apikey}
\PYG{g+go}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{vars}\PYG{p}{(}\PYG{n}{current\PYGZus{}portfolio}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}port\PYGZsq{}: \PYGZob{}\PYGZsq{}AAPL Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x11648b5c0\PYGZgt{},}
\PYG{g+go}{  \PYGZsq{}AMD Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x116442c50\PYGZgt{},}
\PYG{g+go}{  \PYGZsq{}INTC Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x1177b75c0\PYGZgt{},}
\PYG{g+go}{  \PYGZsq{}GOOG Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x1177bc390\PYGZgt{}\PYGZcb{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{vars}\PYG{p}{(}\PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{port}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{AMD Equity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}name\PYGZsq{}: \PYGZsq{}AMD\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}market\PYGZus{}data\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.market\PYGZus{}data.QuandlStockData at 0x11648b2e8\PYGZgt{},}
\PYG{g+go}{ \PYGZsq{}ordered\PYGZus{}price\PYGZsq{}: 11.699999999999999,}
\PYG{g+go}{ \PYGZsq{}quantity\PYGZsq{}: 100,}
\PYG{g+go}{ \PYGZsq{}initial\PYGZus{}value\PYGZsq{}: 1170.0,}
\PYG{g+go}{ \PYGZsq{}date\PYGZus{}ordered\PYGZsq{}: \PYGZsq{}3/9/18\PYGZsq{},}
\PYG{g+go}{ \PYGZsq{}type\PYGZsq{}: \PYGZsq{}Equity\PYGZsq{}\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
At this moment, the \sphinxcode{\sphinxupquote{current\_portfolio}} instance is only a wrapper for
it’s \sphinxcode{\sphinxupquote{port}} attribute, a dictionary containing the securities in the
\sphinxcode{\sphinxupquote{Portfolio}} object. Soon we’ll use this object to mark the portfolio,
create a simulation to estimate value at risk, look at the covariance
variance matrix to calculate a parameterized volatility measure, and
much more.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Portfolio}} class handles interactions with the portfolio data and
the associated securities in the portfolio. If you have a list of
securities you can also just pass the list into the \sphinxcode{\sphinxupquote{Portfolio}}
instance. The following code creates a portfolio of just the AAPL equity
that we created earlier:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}portfolio} \PYG{o}{=} \PYG{n}{sec}\PYG{o}{.}\PYG{n}{Portfolio}\PYG{p}{(}\PYG{p}{[}\PYG{n}{aapl\PYGZus{}stock}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{vars}\PYG{p}{(}\PYG{n}{aapl\PYGZus{}portfolio}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}port\PYGZsq{}: \PYGZob{}\PYGZsq{}AAPL Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x1164b2e80\PYGZgt{}\PYGZcb{}\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
If we want to add a security to this portfolio, we can call the
\sphinxcode{\sphinxupquote{add\_security}} method, to remove a security we call the
\sphinxcode{\sphinxupquote{remove\_security}} method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{amd\PYGZus{}market\PYGZus{}data} \PYG{o}{=} \PYG{n}{QuandlStockData}\PYG{p}{(}
\PYG{g+go}{  ticker=\PYGZsq{}AMD\PYGZsq{},}
\PYG{g+go}{  apikey=apikey}
\PYG{g+go}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{amd\PYGZus{}stock} \PYG{o}{=} \PYG{n}{Equity}\PYG{p}{(}
\PYG{g+go}{  ticker = \PYGZsq{}AAPL\PYGZsq{},}
\PYG{g+go}{  market\PYGZus{}data = amd\PYGZus{}market\PYGZus{}data,}
\PYG{g+go}{  ordered\PYGZus{}price = 11.70,}
\PYG{g+go}{  quantity = 100,}
\PYG{g+go}{  date\PYGZus{}ordered = datetime(2018,3,9)}
\PYG{g+go}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{add\PYGZus{}security}\PYG{p}{(}\PYG{n}{amd\PYGZus{}stock}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{port}
\PYG{g+go}{\PYGZob{}\PYGZsq{}AAPL Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x1164b2e80\PYGZgt{},}
\PYG{g+go}{ \PYGZsq{}AMD Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x11791cc88\PYGZgt{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{remove\PYGZus{}security}\PYG{p}{(}\PYG{n}{amd\PYGZus{}stock}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{port}
\PYG{g+go}{\PYGZob{}\PYGZsq{}AAPL Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x1164b2e80\PYGZgt{}\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{remove\PYGZus{}security}\PYG{p}{(}\PYG{n}{aapl\PYGZus{}stock}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{port}
\PYG{g+go}{\PYGZob{}\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Calculating Risk Metrics and Using the Portfolio class}
\label{\detokenize{gettingstarted:calculating-risk-metrics-and-using-the-portfolio-class}}
\sphinxAtStartPar
Now that we have our \sphinxcode{\sphinxupquote{Portfolio}} constructed with the securities we
have on the book, let’s use the class to calculate some market risk
metrics.


\subsubsection{Marking the Portfolio}
\label{\detokenize{gettingstarted:marking-the-portfolio}}
\sphinxAtStartPar
Let’s first mark the current portfolio. Since we want to know the
current value of the portfolio, the mark method will calculate the value
of the portfolio at the current price for each security. The current
price is going to be the last known mark, the price at the closest date
to today.
\begin{quote}

\sphinxAtStartPar
Note: Since the \sphinxcode{\sphinxupquote{QuandlStockData}} source hasn’t been updated since
3/27/2018, we would expect the last shared date to be 3/27/2018.
However, you should use the last shared date as a flag to see if an
asset’s \sphinxcode{\sphinxupquote{\_MarketData}} isn’t updating. With certain assets, such as
Bonds or illiquid securities, marking daily might not make as much
sense, so common shared date doesn’t mean as much.
\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{mark}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{vars}\PYG{p}{(}\PYG{n}{current\PYGZus{}portfolio}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}port\PYGZsq{}: \PYGZob{}\PYGZsq{}AAPL Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x10f8b2940\PYGZgt{},}
\PYG{g+go}{  \PYGZsq{}AMD Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x1a1f6b0908\PYGZgt{},}
\PYG{g+go}{  \PYGZsq{}INTC Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x110538d30\PYGZgt{},}
\PYG{g+go}{  \PYGZsq{}GOOG Equity\PYGZsq{}: \PYGZlt{}risk\PYGZus{}dash.securities.Equity at 0x110548e10\PYGZgt{}\PYGZcb{},}
\PYG{g+go}{ \PYGZsq{}market\PYGZus{}change\PYGZsq{}: \PYGZhy{}1476.6999999999989,}
\PYG{g+go}{ \PYGZsq{}marked\PYGZus{}portfolio\PYGZsq{}: \PYGZob{}\PYGZsq{}AAPL Equity\PYGZsq{}: (8999.0, 8417.0),}
\PYG{g+go}{  \PYGZsq{}AMD Equity\PYGZsq{}: (1170.0, 1000.0),}
\PYG{g+go}{  \PYGZsq{}INTC Equity\PYGZsq{}: (\PYGZhy{}2609.5, \PYGZhy{}2559.5),}
\PYG{g+go}{  \PYGZsq{}GOOG Equity\PYGZsq{}: (5800.1999999999998, 5025.5)\PYGZcb{},}
\PYG{g+go}{ \PYGZsq{}date\PYGZus{}marked\PYGZsq{}: Timestamp(\PYGZsq{}2018\PYGZhy{}03\PYGZhy{}27 00:00:00\PYGZsq{}),}
\PYG{g+go}{ \PYGZsq{}initial\PYGZus{}value\PYGZsq{}: 13359.700000000001\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{mark}} method now creates the \sphinxcode{\sphinxupquote{marked\_portfolio}} dictionary that
stores a tuple, (initial\_value, market\_value), for every security in the
portfolio. We also now can calculate a quick holding period return:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{holdingreturn} \PYG{o}{=} \PYG{p}{(}\PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{market\PYGZus{}change}\PYG{p}{)}\PYG{o}{/}\PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{initial\PYGZus{}value}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{holdingreturn}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}0.11053391917483169}
\end{sphinxVerbatim}

\sphinxAtStartPar
This hypothetical portfolio apparently hasn’t performed over the month
since inception, it’s lost 11\%, but let’s look at historic returns
before we give up on the portfolio. We can call \sphinxcode{\sphinxupquote{portfolio.quick\_plot}}
to look at a \sphinxcode{\sphinxupquote{matplotlib}} generated cumulative return series of the
portfolio. If you wanted more control over plotting, you could use the
returned \sphinxcode{\sphinxupquote{pandas DataFrame}}. In fact, the current implementation is
just using the \sphinxcode{\sphinxupquote{pandas DataFrame}} method \sphinxcode{\sphinxupquote{plot()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{marketdata} \PYG{o}{=} \PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{quick\PYGZus{}plot}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{quick_plot_image}.png}
\caption{quick\_plot() Output}\label{\detokenize{gettingstarted:id1}}\end{figure}


\subsubsection{Parametrically Calculating the Value at Risk}
\label{\detokenize{gettingstarted:parametrically-calculating-the-value-at-risk}}
\sphinxAtStartPar
As we can see, this portfolio is pretty volatile, but has almost doubled
over the last four years. Let’s calculate what the portfolio daily
volatility over the period based off the percent change by calling
\sphinxcode{\sphinxupquote{get\_port\_volatility}} using \sphinxcode{\sphinxupquote{percentchange}} from the
\sphinxcode{\sphinxupquote{market\_data}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{variance}\PYG{p}{,} \PYG{n}{value\PYGZus{}at\PYGZus{}risk} \PYG{o}{=} \PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{set\PYGZus{}port\PYGZus{}variance}\PYG{p}{(}
\PYG{g+go}{  key = \PYGZsq{}percentchange\PYGZsq{}}
\PYG{g+go}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{volatility} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{variance}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{volatility}\PYG{p}{)}
\PYG{g+go}{0.01345831069378136}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mean} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{market\PYGZus{}data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{portfolio}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{mean}\PYG{p}{)}
\PYG{g+go}{0.0007375242310493472}
\end{sphinxVerbatim}

\sphinxAtStartPar
We calculated 1.3\% daily standard deviation or daily volatility, if the
distribution is normally distributed around zero, then we would expect
that 95\% of the data is contained within approximately 2 standard
deviations. We can visually confirm, as well as look to see if there are
other distributional aspects we can visually distinguish:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{marketdata}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{portfolio}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{bins}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Portfolio Historic Returns}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{n}{temp} \PYG{o}{*} \PYG{l+m+mf}{1.96}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} if centered around zero, then}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{axvline}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{temp} \PYG{o}{*} \PYG{l+m+mf}{1.96}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{linestyle}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}\PYGZhy{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{portfolio_returns}.png}
\caption{Portfolio Returns}\label{\detokenize{gettingstarted:id2}}\end{figure}

\sphinxAtStartPar
This distribution looks highly centered around zero, which could signal
kurtosis. This seems indicative of equity data, especially for daily
returns. Right now, a good place to start thinking about metric
parameterization is to assume normality and independence in daily
returns. While this assumption might not be very good or might vary
between security to security in the portfolio, which we can account for
in simulation or purely using historic returns to calculate risk
metrics, we can use this distribution assumption to quickly get a Value
at Risk metric over a time horizon.

\sphinxAtStartPar
The default time horizon is 10 days at a 95\% confidence level for the
\sphinxcode{\sphinxupquote{set\_port\_variance}} method, so if we look at the returned
\sphinxcode{\sphinxupquote{value\_at\_risk}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{value\PYGZus{}at\PYGZus{}risk}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}0.083413941112170473}
\end{sphinxVerbatim}

\sphinxAtStartPar
This value is simply the standard deviation scaled by time, at the
critical value specified:
\begin{equation*}
\begin{split}VaR_{t, T} = \sigma \cdot \sqrt{T-t} \cdot Z^{*}_{p = \alpha}\end{split}
\end{equation*}
\sphinxAtStartPar
We can interpret this Value at Risk as being the lower bound of the 95\%
confidence interval for the 10 day distribution. For this portfolio, on
average, a loss over 10 days less than 8.3\% should occur 2.5\% of the
time. To get the dollar value of the 10 Day Value at Risk, we would just
multiply this percent change by the current portfolio market value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{dollar\PYGZus{}value\PYGZus{}at\PYGZus{}risk} \PYG{o}{=} \PYG{n}{value\PYGZus{}at\PYGZus{}risk} \PYG{o}{*} \PYG{p}{(}\PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{initial\PYGZus{}value} \PYG{o}{+} \PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{marked\PYGZus{}change}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{dollar\PYGZus{}value\PYGZus{}at\PYGZus{}risk}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}991.20786223592188}
\end{sphinxVerbatim}

\sphinxAtStartPar
Similarly, we could interpret as over the a 10 day period, on average,
2.5\% of the time there could be an approximate loss over \$991.21 dollars
for this portfolio. However, this is relying on the assumption that the
portfolio is: a) normally distributed, and b) daily returns are serially
independent and identically distributed. One way we can go around this
is to look at the historic distribution

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{historic\PYGZus{}distribution}\PYG{p}{,} \PYG{n}{historic\PYGZus{}var} \PYG{o}{=} \PYG{n}{current\PYGZus{}portfolio}\PYG{o}{.}\PYG{n}{historic\PYGZus{}var}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{historic\PYGZus{}var}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}0.073051970330112487}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is calculated by doing a cumulative sum of returns over each
horizon time period, then taking the appropriate percentile of the
distribution to get a VaR based on historic prices. This is is smaller
than the parametric VaR due to the fact that the distribution looks more
right skewed as shown below

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{historic_10_return}.png}
\caption{Historic 10D VaR}\label{\detokenize{gettingstarted:id3}}\end{figure}

\sphinxAtStartPar
This method is fairly simple, however it is based on the assumption that
the previous distribution of outcomes is a good representation of the
future distribution.

\sphinxAtStartPar
Another way we’ve implemented to calculate the value at risk is to
simulate the portfolio distribution.


\subsection{Simulating the Portfolio}
\label{\detokenize{gettingstarted:simulating-the-portfolio}}
\sphinxAtStartPar
When simulating portfolio returns, one’s objective is to correctly
specify the portfolio distribution. I consider two major approaches,
“bottom\sphinxhyphen{}up” and “top\sphinxhyphen{}down”.

\sphinxAtStartPar
The “bottom\sphinxhyphen{}up” approach would include simulating the underlying
securities first and then valuing the portfolio through the simulated
distributions. The major strength of this method is the ability to
easily value the effect of derivative securities on the portfolio. Since
one would simulate the derivative’s underlier, you could easily then
apply the associated value function through the simulated distribution
to get the security’s profit and loss distribution. Another benefit to
this methodology is the analyst has the freedom to change the simulation
process at a security level. General Brownian motion might be a good
assumption for long/short equity positions, but maybe not as good when
simulating yield curves for bonds. Another strength would be the ability
to change portfolio weights of securities post simulation, if you
simulate a base unit of the security you could then scale the weights
accordingly to easily reweigh the portfolio. The biggest challenge to
this methodology is to ensure that each simulation value represents the
same market environment, meaning that each simulation pull represents
the same environment state. While you can potentially do a convolution
of the different simulations to get a representative joint distribution
of the portfolio, you must ensure that one is capturing the covariance
between the securities. For example, equities and bonds have
historically had negative correlation to each other, thus a portfolio
containing both would potentially have a lower variance than each
security separate. To capture that in a simulation one would have to
simulate directly from the variance\sphinxhyphen{}covariance matrix or do a
convolution to combine separate simulations together. While both are
possible, and in practice it is probably a preferred methodology,
however it’s not within the scope of this project.

\sphinxAtStartPar
The “top\sphinxhyphen{}down” approach would include aggregating the portfolio a priori
and then simulating that distribution. Since the portfolio is made of
the member securities, thus the aggregated distribution represents all
covariance. While this method gets a little be trickier to handle with
derivative securities, since you would need historic market prices per
contract and potentially roll adjust through the time period, for
securities like equities the assumption seems arguable. The benefit of
this method would be having to deal with one simulation and verifying if
it represents the underlying distribution vs having several different
simulations and verifying if they accurately represent the covariance of
constituent securities. The drawback is having less flexibility in the
modeling of individual securities within the portfolio. Another drawback
is to change the weighting or portfolio members, one must recombine and
simulate the new portfolio, which could be computationally intensive
depending on the methodology.

\sphinxAtStartPar
Either way, to implement simulation, the \sphinxcode{\sphinxupquote{\_Simulation}} and
\sphinxcode{\sphinxupquote{\_RandomGen}} class that handle the calculation and generation
respectfully. For example, to implement a naive return model, the
included \sphinxcode{\sphinxupquote{NaiveMonteCarlo}} class represents the following generation
function for a single observation:
\begin{equation*}
\begin{split}R_{t} = \phi\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\phi\) representing a pull from an imposed distribution. As
such, we need to specify that imposed distribution, thus we include the
\sphinxcode{\sphinxupquote{NormalDistribution \_RandomGen}} class to generate a pull. This class
is just a wrapper to for numpy.random.normal with the mean and standard
deviation specified in the initialization.

\sphinxAtStartPar
Since the aim is to specify the portfolio distribution X days into the
future, we want to simulate a cumulative return path through time. Under
the assumption that each day is independent, the individual simulation
path is then:
\begin{equation*}
\begin{split}P = \sum_{t=1}^{X} R_{t} = \sum_{t=1}^{X} \phi\end{split}
\end{equation*}
\sphinxAtStartPar
Now to fully specify the distribution via a Monte Carlo process, we will
generate \(Y\) paths to represent the underlying \(X\) day
distribution. To get the mean of the distribution at each \(t\) step
from 1 to \(X\):
\begin{equation*}
\begin{split}E(R_{t}) = \frac{1}{Y} \sum_{i=1}^{Y} P_{t, i} + E((R_{t-1}))\end{split}
\end{equation*}
\sphinxAtStartPar
To get the variance:
\begin{equation*}
\begin{split}Var(R_{t}) = E\left(\left(R_{t} - E(R_{t})\right)^{2}\right) + Var(R_{t}) = \frac{1}{Y^{2}} \sum_{i=1}^{Y}\left(P_{t,i} - \bar{P_{t}} \right)\end{split}
\end{equation*}
\sphinxAtStartPar
Since each return is assumed independently and identically distributed,
the above condenses to:
\begin{equation*}
\begin{split}Var(R_{t}) = t \cdot Var(R_{t})\end{split}
\end{equation*}
\sphinxAtStartPar
Since we can now switch out the distribution of \(\phi\) to
represent the portfolio or constituent securities, this generation
function is agnostic of which approach explained above is taken. It’s
for that reason the design choice was made to make the \sphinxcode{\sphinxupquote{\_RandomGen}}
and \sphinxcode{\sphinxupquote{\_Simulation}} classes seperate instead of building methods
directly into the \sphinxcode{\sphinxupquote{Portfolio}} or \sphinxcode{\sphinxupquote{\_Security}} class.


\subsubsection{Simulating a Unit Resolution Distribution}
\label{\detokenize{gettingstarted:simulating-a-unit-resolution-distribution}}
\sphinxAtStartPar
First let’s simulate a unit resolution distribution. By default, the
resolution is one day, but depending on the market data resolution you
could simulate to match. Since the default is one day, let’s simulate a
one day distribution and then simulate a X day forward path distribution
using \sphinxcode{\sphinxupquote{aapl\_stock}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{risk\PYGZus{}dash}\PYG{n+nn}{.}\PYG{n+nn}{simgen} \PYG{k+kn}{import} \PYG{n}{NormalDistribution}\PYG{p}{,} \PYG{n}{NaiveMonteCarlo}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{log\PYGZus{}return\PYGZus{}generator} \PYG{o}{=} \PYG{n}{NormalDistribution}\PYG{p}{(}
\PYG{g+go}{    location = aapl\PYGZus{}stock.market\PYGZus{}data.currentexmean,}
\PYG{g+go}{    scale = aapl\PYGZus{}stock.market\PYGZus{}data.currentexvol}
\PYG{g+go}{  )}
\end{sphinxVerbatim}

\sphinxAtStartPar
Since we’re just simulating one day, we can directly use the generator
object simulate a one day return distribution. With our new
\sphinxcode{\sphinxupquote{log\_return\_generator}} instance, we are assuming a normally
distributed return series. By default, using \sphinxcode{\sphinxupquote{currentexmean}} will
center the distribution around the closest 80 day exponentially weighted
mean of daily AAPL returns. Similarly, using \sphinxcode{\sphinxupquote{currentexvol}} will set
the standard deviation to the closest 80 day exponentially weighted
standard deviation of historic daily AAPL returns. To simulate one pull
now from a normal distribution, we have an observation that represents a
log return of AAPL.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{log\PYGZus{}return\PYGZus{}generator}\PYG{o}{.}\PYG{n}{generate}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+go}{array([\PYGZhy{}0.00948158])}
\end{sphinxVerbatim}

\sphinxAtStartPar
One observation isn’t really helpful for us, we now want to simulate an
arbitrarily large amount of observations to converge to the underlying
distribution. In this case, let’s simulate 5000 observations:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{one\PYGZus{}day\PYGZus{}simluation} \PYG{o}{=} \PYG{n}{log\PYGZus{}return\PYGZus{}generator}\PYG{o}{.}\PYG{n}{generate}\PYG{p}{(}\PYG{l+m+mi}{5000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{one\PYGZus{}day\PYGZus{}simulation}\PYG{p}{)}
\PYG{g+go}{5000}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{one\PYGZus{}day\PYGZus{}simluation}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}0.00036139846164594291}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aapl\PYGZus{}stock}\PYG{o}{.}\PYG{n}{market\PYGZus{}data}\PYG{o}{.}\PYG{n}{currentexmean}
\PYG{g+go}{\PYGZhy{}0.00040076765463907944}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}np.std(one\PYGZus{}day\PYGZus{}simulation)}
\PYG{g+go}{0.016497493178538599}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}aapl\PYGZus{}stock.market\PYGZus{}data.currentexvol}
\PYG{g+go}{0.016485817752205818}
\end{sphinxVerbatim}

\sphinxAtStartPar
To parameterize the sampling distribution of the distribution, we can
simulate an arbitrarily large amount of simulations to converge to the
sampling distribution:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{multiple\PYGZus{}one\PYGZus{}day\PYGZus{}simulations} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{log\PYGZus{}return\PYGZus{}generator}\PYG{o}{.}\PYG{n}{generate}\PYG{p}{(}\PYG{l+m+mi}{5000}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{l+m+mi}{5000}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{multiple\PYGZus{}one\PYGZus{}day\PYGZus{}simulations}\PYG{p}{,} \PYG{n}{axis} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} sampling distribution mean of the simulation mean}
\PYG{g+go}{\PYGZhy{}0.00039625427660093282}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{multiple\PYGZus{}one\PYGZus{}day\PYGZus{}simulations}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.00023461080665209953}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{mean}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{multiple\PYGZus{}one\PYGZus{}day\PYGZus{}simulations}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.016484835778989758}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{std}\PYG{p}{(}\PYG{n}{multiple\PYGZus{}one\PYGZus{}day\PYGZus{}simulations}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{0.00016629650698145025}
\end{sphinxVerbatim}

\sphinxAtStartPar
With the mean and standard deviation of the sampling distribution we can
construct confidence intervals to see if our calculated mean and
variance is contained. This would imply we have specified the imposed
distribution based on our calculation of \sphinxcode{\sphinxupquote{currentexvol}} and
\sphinxcode{\sphinxupquote{currentexmean}}. The calculation for a 95\% confidence level is:
\begin{equation*}
\begin{split}\bar{X} \pm Z^{*}_{p=\alpha} \frac{s}{\sqrt{n}}\end{split}
\end{equation*}
\sphinxAtStartPar
So for this case, for a 95\% confidence level, \(1-\alpha\), our
confidence interval for the simulation mean is (\sphinxhyphen{}0.0004027, \sphinxhyphen{}0.0003897)
and for the simulation standard deviation is (0.0164802, 0.0164894). Our
calculated historic values, \sphinxhyphen{}0.0004007 and 0.0164858, both fall within
those confidence intervals so at the 95\% confidence level we can
determine this simulation represents a normally distributed one day
return series.


\subsubsection{Simulating a Path Distribution}
\label{\detokenize{gettingstarted:simulating-a-path-distribution}}
\sphinxAtStartPar
To simulate a forward return path of independent returns, we now want to
create a \sphinxcode{\sphinxupquote{NaiveMonteCarlo}} object to simulate \(Y\) forward
resolution paths.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{simulation\PYGZus{}generator} \PYG{o}{=} \PYG{n}{NaiveMonteCarlo}\PYG{p}{(}\PYG{n}{log\PYGZus{}return\PYGZus{}generator}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{NaiveMonteCarlo}} accepts any \sphinxcode{\sphinxupquote{\_RandomGen}} object, so we could
potentially pass a \sphinxcode{\sphinxupquote{\_RandomGen}} object that might more accurately
represent our underlying data. For example, if we thought that AAPL was
distributed with a Cauchy distribution to capture fatter tails, we could
pass in a \sphinxcode{\sphinxupquote{\_RandomGen}} object that represented the distribution. Now
we’ll maintain the assumption that the log returns are normally
distributed and use the \sphinxcode{\sphinxupquote{generator}} instance we created earlier.

\sphinxAtStartPar
To simulate 5000 paths for a 5 day forward distribution, we would then
call the \sphinxcode{\sphinxupquote{simulate}} method passing the arguments \sphinxcode{\sphinxupquote{periods\_forward=5}}
and \sphinxcode{\sphinxupquote{number\_of\_simulations=5000}}. This will set the
\sphinxcode{\sphinxupquote{simulation\_mean}}, \sphinxcode{\sphinxupquote{simulation\_std}}, and \sphinxcode{\sphinxupquote{simulated\_distribution}}
attributes and return the simulated distribution.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{path\PYGZus{}simulation} \PYG{o}{=} \PYG{n}{simulation\PYGZus{}generator}\PYG{o}{.}\PYG{n}{simulate}\PYG{p}{(}\PYG{n}{periods\PYGZus{}forward}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{number\PYGZus{}of\PYGZus{}simulations}\PYG{o}{=}\PYG{l+m+mi}{5000}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{path\PYGZus{}simulation}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(5000,5)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{simulation\PYGZus{}generator}\PYG{o}{.}\PYG{n}{simulation\PYGZus{}mean}
\PYG{g+go}{array([\PYGZhy{}0.00050452, \PYGZhy{}0.00082389, \PYGZhy{}0.00105195, \PYGZhy{}0.00135753, \PYGZhy{}0.0019303 ])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{simulation\PYGZus{}generator}\PYG{o}{.}\PYG{n}{simulation\PYGZus{}std}
\PYG{g+go}{array([ 0.01630096,  0.02311434,  0.0283451 ,  0.03211978,  0.03607576])}
\end{sphinxVerbatim}

\sphinxAtStartPar
The simulation distribution now is 5000 individual 5 day paths,
represented as a \sphinxcode{\sphinxupquote{numpy}} array of shape (5000,5). The
\sphinxcode{\sphinxupquote{simulation\_mean}} and \sphinxcode{\sphinxupquote{simulation\_std}} are then calculated across
the column axis, giving us the simulated generation through time. Since
this method is fairly naive, essentially the cumulative sum of
independent random normals, it makes sense that the \sphinxcode{\sphinxupquote{simulation\_mean}}
vector is essentially \(E(R_{t}) = t \cdot E(R_{t=1})\) and
\(S.D.(R_{t}) = \sqrt{t} * S.D.(R_{t=1})\). If we wanted to
implement a more standard approach of simulating returns, we could then
create a \sphinxcode{\sphinxupquote{\_Simulation}} class that would represent the value function.
To simulate the portfolio from the top down approach, we would then just
use the portfolio mean and variance to then simulate the portfolio.


\section{Summary}
\label{\detokenize{gettingstarted:summary}}
\sphinxAtStartPar
While this is just the first introduction to the package, there are many
expandable directions to go. The aim for the package is to help
formalize the development process by providing clear template classes
and use cases. The next steps are to write \sphinxcode{\sphinxupquote{\_Security}} classes that
match the portfolio that the analyst is trying to model and
\sphinxcode{\sphinxupquote{\_MarketData}} classes that match the specific data store for the
application.


\chapter{risk\_dash Dash application documentation}
\label{\detokenize{dashapp_documentation:risk-dash-dash-application-documentation}}\label{\detokenize{dashapp_documentation:dashapp-documentation}}\label{\detokenize{dashapp_documentation::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:risk_dash-dash-application-documentation}]{\emph{risk\_dash Dash application
documentation}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:overview}]{\emph{Overview}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:getting-started---locally-running-the-dash-app}]{\emph{Getting Started \sphinxhyphen{} Locally Running the Dash
App}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:dash-applications}]{\emph{Dash applications}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:the-risk_dash-dash-object}]{\emph{The risk\_dash Dash object}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:running-the-application-locally}]{\emph{Running the application
locally}}}

\end{itemize}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:application-usage}]{\emph{Application Usage}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:individual-equity-analysis-page---single_tickerpy}]{\emph{Individual Equity Analysis Page \sphinxhyphen{}
single\_ticker.py}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:portfolio-metrics---portfolio_metricspy}]{\emph{Portfolio Metrics \sphinxhyphen{}
portfolio\_metrics.py}}}

\end{itemize}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{dashapp_documentation:summary}]{\emph{Summary}}}

\end{itemize}

\end{itemize}


\section{Overview}
\label{\detokenize{dashapp_documentation:overview}}
\sphinxAtStartPar
The included \sphinxhref{https://dash.plotly.com/}{Dash} application is purely
to demonstrate a use case for the \sphinxcode{\sphinxupquote{risk\_dash}} package. There is
minimal css provided through using
\sphinxhref{https://getbootstrap.com/docs/4.0/getting-started/introduction/}{Bootstrap}
and the \sphinxhref{https://dash-bootstrap-components.opensource.faculty.ai/}{Dash Bootstrap
Components}
python library. For a complete overview of Dash, please check the
respective documentation, as this will be very high level and explain
the basics of how the sample application works.


\section{Getting Started \sphinxhyphen{} Locally Running the Dash App}
\label{\detokenize{dashapp_documentation:getting-started-locally-running-the-dash-app}}

\subsection{Dash applications}
\label{\detokenize{dashapp_documentation:dash-applications}}
\sphinxAtStartPar
To quote the \sphinxhref{https://dash.plotly.com/introduction}{Dash}
documentation:
\begin{quote}

\sphinxAtStartPar
Dash is a productive Python framework for building web analytic
applications. Written on top of Flask, Plotly.js, and React.js, Dash
is ideal for building data visualization apps with highly custom user
interfaces in pure Python. It’s particularly suited for anyone who
works with data in Python.
\end{quote}

\sphinxAtStartPar
Due to it’s lightweight nature and pure python syntax, it’s a great use
case to show off the functionality of the \sphinxcode{\sphinxupquote{risk\_dash}} framework. Dash
applications are typically single purpose and leverage \sphinxcode{\sphinxupquote{plotly.js}} for
it’s graphic capabilities. This application is structured in a way to
have multiple pages using JavaScript callback functionality. These pages
are rendered in the \sphinxcode{\sphinxupquote{app.layout}} found in \sphinxcode{\sphinxupquote{dashapp.py}}, then when an
HTTP request is then made to the \sphinxcode{\sphinxupquote{Flask}} server, the application’s
callback structure then updates the HTML Div container on the main index
page and renders the according webpage. Each HTML and interactive object
is referenced by it’s \sphinxcode{\sphinxupquote{id}} attribute, so each callback uses those
references to pass along data and respond interactively. For this Dash
application, the main callback function is taking the individually
described page layouts and displaying them in the main \sphinxcode{\sphinxupquote{Div}}
container.

\sphinxAtStartPar
For example, from \sphinxcode{\sphinxupquote{dashapp.py}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@app}\PYG{o}{.}\PYG{n}{callback}\PYG{p}{(}
    \PYG{n}{Output}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{page\PYGZus{}content}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{children}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{[}\PYG{n}{Input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{url}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pathname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}
\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{get\PYGZus{}layout}\PYG{p}{(}\PYG{n}{url}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{url} \PYG{o}{!=} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{url} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/portfolio}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
            \PYG{k}{return}\PYG{p}{(}\PYG{n}{portfolio\PYGZus{}metrics}\PYG{o}{.}\PYG{n}{layout}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n}{url} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/single}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
            \PYG{k}{return}\PYG{p}{(}\PYG{n}{single\PYGZus{}ticker}\PYG{o}{.}\PYG{n}{layout}\PYG{p}{)}
        \PYG{k}{elif} \PYG{n}{url} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/docs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
            \PYG{k}{return}\PYG{p}{(}\PYG{n}{dcc}\PYG{o}{.}\PYG{n}{Markdown}\PYG{p}{(}\PYG{n}{docs}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{k}{return}\PYG{p}{(}\PYG{n}{dcc}\PYG{o}{.}\PYG{n}{Markdown}\PYG{p}{(}\PYG{n}{readme}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function takes the URL given as input, then returns the respective
HTML object to populate the children attribute of the \sphinxcode{\sphinxupquote{page\_content}}
\sphinxcode{\sphinxupquote{Div}}\sphinxhyphen{}like object in the main \sphinxcode{\sphinxupquote{app.layout}}. The decorator
\sphinxcode{\sphinxupquote{@app.callback}} registers this function with the \sphinxcode{\sphinxupquote{app Dash}} object,
explained {\hyperref[\detokenize{dashapp_documentation:the-risk_dash-dash-object}]{\emph{below}}}.

\sphinxAtStartPar
Since one of the objects of the \sphinxcode{\sphinxupquote{risk\_dash}} framework is to create an
in memory risk valuation engine, this included app has two main pages:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Individual Equity Analysis \sphinxcode{\sphinxupquote{single\_ticker.py}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Shows how the \sphinxcode{\sphinxupquote{\_Security}} and \sphinxcode{\sphinxupquote{\_MarketData}} can be used to
value a single security and run a Monte Carlo simulation

\end{itemize}

\item {} 
\sphinxAtStartPar
Portfolio Dashboard \sphinxcode{\sphinxupquote{portfolio\_metrics.py}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Shows how the \sphinxcode{\sphinxupquote{Portfolio}} object can value a collection of
\sphinxcode{\sphinxupquote{\_Security}} objects

\end{itemize}

\end{itemize}

\sphinxAtStartPar
As seen above, the URL ending in /portfolio/ returns the
\sphinxcode{\sphinxupquote{portfolio\_metrics.layout}} member, the /single returns the
\sphinxcode{\sphinxupquote{single\_ticker.layout}} member, /docs returns an HTML version of the
getting started documentation, and any other URL returns the README.

\sphinxAtStartPar
The file structure of the app is as follows with a bit more detail than
the README.md:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{n}{app}\PYG{o}{.}\PYG{n}{py} \PYG{c+c1}{\PYGZsh{} contains server level configurations}
\PYG{o}{\PYGZhy{}}\PYG{n}{dashapp}\PYG{o}{.}\PYG{n}{py} \PYG{c+c1}{\PYGZsh{} contains application level routing and main structure}
\PYG{o}{\PYGZhy{}}\PYG{n}{pages} \PYG{c+c1}{\PYGZsh{} the layout rendering and callback functions to create each page}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{portfolio\PYGZus{}metrics}\PYG{o}{.}\PYG{n}{py} \PYG{c+c1}{\PYGZsh{} displays a portfolio level risk}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{single\PYGZus{}ticker}\PYG{o}{.}\PYG{n}{py} \PYG{c+c1}{\PYGZsh{} displays a single equity position risk}
\PYG{o}{\PYGZhy{}}\PYG{n}{objects} \PYG{c+c1}{\PYGZsh{} risk\PYGZus{}dash framework objects}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{securities}\PYG{o}{.}\PYG{n}{py} \PYG{c+c1}{\PYGZsh{} security objects}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{simgen}\PYG{o}{.}\PYG{n}{py} \PYG{c+c1}{\PYGZsh{} simulation objects}
  \PYG{o}{|} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{market\PYGZus{}data}\PYG{o}{.}\PYG{n}{py} \PYG{c+c1}{\PYGZsh{} market data objects}
\end{sphinxVerbatim}

\sphinxAtStartPar
To add a page to the application, the process is simple:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Create a \sphinxcode{\sphinxupquote{.py}} file that contains the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{dash\_html\_components.Div}} object to replace the children of
the \sphinxcode{\sphinxupquote{app.layout\#page\_content}} named \sphinxcode{\sphinxupquote{layout}}

\item {} 
\sphinxAtStartPar
The respective callback functions to populate the content of the
\sphinxcode{\sphinxupquote{dash\_html\_components.Div}} and register them with the
\sphinxcode{\sphinxupquote{app.app}} object

\end{itemize}

\item {} 
\sphinxAtStartPar
In the \sphinxcode{\sphinxupquote{dashapp.py}} file, register the desired URL in the
\sphinxcode{\sphinxupquote{get\_layout}} function and return the \sphinxcode{\sphinxupquote{layout}} member of the
created \sphinxcode{\sphinxupquote{.py}} file

\end{itemize}


\subsection{The risk\_dash Dash object}
\label{\detokenize{dashapp_documentation:the-risk-dash-dash-object}}
\sphinxAtStartPar
Referring from the \sphinxhref{https://dash.plotly.com/}{Dash} documentation and
source code, the Dash object handles all of the rendering of the
JavaScript and HTML components of our defined application. This object
is defined in \sphinxcode{\sphinxupquote{app.py}}, where we define a couple of server level
configurations. Here are the important definitions below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{dash}
\PYG{k+kn}{import} \PYG{n+nn}{dash\PYGZus{}bootstrap\PYGZus{}components} \PYG{k}{as} \PYG{n+nn}{dbc}

\PYG{n}{style\PYGZus{}sheets} \PYG{o}{=} \PYG{p}{[}\PYG{n}{dbc}\PYG{o}{.}\PYG{n}{themes}\PYG{o}{.}\PYG{n}{BOOTSTRAP}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}add in the css stylesheets for Bootstrap}
\PYG{n}{app} \PYG{o}{=} \PYG{n}{dash}\PYG{o}{.}\PYG{n}{Dash}\PYG{p}{(}\PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}}\PYG{p}{,} \PYG{n}{external\PYGZus{}stylesheets}\PYG{o}{=}\PYG{n}{style\PYGZus{}sheets}\PYG{p}{,}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} main application initialization}

\PYG{n}{server} \PYG{o}{=} \PYG{n}{app}\PYG{o}{.}\PYG{n}{server} \PYG{c+c1}{\PYGZsh{} exposing the underlying Flask server}
\PYG{n}{app}\PYG{o}{.}\PYG{n}{config}\PYG{o}{.}\PYG{n}{suppress\PYGZus{}callback\PYGZus{}exceptions} \PYG{o}{=} \PYG{k+kc}{True} \PYG{c+c1}{\PYGZsh{} configuration to suppress exceptions relating to the multi\PYGZhy{}page configuration}
\end{sphinxVerbatim}

\sphinxAtStartPar
The defined \sphinxcode{\sphinxupquote{app}} object is the \sphinxcode{\sphinxupquote{Dash}} instance that will need to
register all of the defined callbacks we create. The \sphinxcode{\sphinxupquote{server}} object
is the underlying \sphinxcode{\sphinxupquote{Flask}} server instance that hosts and interacts
with the incoming HTTP requests. After defining these, we then import
them to the \sphinxcode{\sphinxupquote{dashapp.py}} file that will define the main, application
level, functionality.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} dash dependencies/modules}
\PYG{k+kn}{import} \PYG{n+nn}{dash\PYGZus{}core\PYGZus{}components} \PYG{k}{as} \PYG{n+nn}{dcc}
\PYG{k+kn}{import} \PYG{n+nn}{dash\PYGZus{}bootstrap\PYGZus{}components} \PYG{k}{as} \PYG{n+nn}{dbc}
\PYG{k+kn}{import} \PYG{n+nn}{dash\PYGZus{}html\PYGZus{}components} \PYG{k}{as} \PYG{n+nn}{html}
\PYG{k+kn}{from} \PYG{n+nn}{dash}\PYG{n+nn}{.}\PYG{n+nn}{dependencies} \PYG{k+kn}{import} \PYG{n}{Input}\PYG{p}{,} \PYG{n}{Output}

\PYG{c+c1}{\PYGZsh{} application level code}
\PYG{k+kn}{from} \PYG{n+nn}{app} \PYG{k+kn}{import} \PYG{n}{app}\PYG{p}{,} \PYG{n}{server}
\PYG{k+kn}{from} \PYG{n+nn}{pages} \PYG{k+kn}{import} \PYG{n}{single\PYGZus{}ticker}\PYG{p}{,} \PYG{n}{portfolio\PYGZus{}metrics}
\PYG{c+c1}{\PYGZsh{} ...}

\PYG{c+c1}{\PYGZsh{} the main application layout, defines the NavBar and the container that will store the rendered HTML from pages}
\PYG{n}{app}\PYG{o}{.}\PYG{n}{layout} \PYG{o}{=} \PYG{n}{dbc}\PYG{o}{.}\PYG{n}{Container}\PYG{p}{(}
\PYG{c+c1}{\PYGZsh{} ...}
\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} if this is run as a script, then run the server}
\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Running}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{app}\PYG{o}{.}\PYG{n}{run\PYGZus{}server}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
When this script is then run with \sphinxcode{\sphinxupquote{python dashapp.py}} or otherwise,
all of the namespaces are loaded in, thus the Dash object registers the
defined callbacks with the associated component inputs and HTML outputs
and is ready to receive HTTP requests.

\sphinxAtStartPar
Next, we’ll briefly talk about how to run the server locally, though it
could be deployed on a remote server and receive HTTP requests over the
broader internet.


\subsection{Running the application locally}
\label{\detokenize{dashapp_documentation:running-the-application-locally}}
\sphinxAtStartPar
To run the server locally using the underlying Flask Server, run the
following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{python} \PYG{n}{dashapp}\PYG{o}{.}\PYG{n}{py}
\end{sphinxVerbatim}

\sphinxAtStartPar
This runs the file as a script, loads in the necessary namespaces, and
calls the \sphinxcode{\sphinxupquote{app.run\_server()}} method. Additonally, since the \sphinxcode{\sphinxupquote{Flask}}
app isn’t intended to be a production server, in a production
environment we might want to use \sphinxcode{\sphinxupquote{gunicorn}} to run the server. We
would just run \sphinxcode{\sphinxupquote{gunicorn dashapp:server}} from the command line
instead. Running the server with the \sphinxcode{\sphinxupquote{Flask}} app locally for testing
and proof of concept, calling \sphinxcode{\sphinxupquote{python dashapp.py}} will run the server
on the default port/local ip address, \sphinxurl{http://127.0.0.1:8050/}, where you
can then open the application in a web browser like Chrome.


\section{Application Usage}
\label{\detokenize{dashapp_documentation:application-usage}}

\subsection{Individual Equity Analysis Page \sphinxhyphen{} single\_ticker.py}
\label{\detokenize{dashapp_documentation:individual-equity-analysis-page-single-ticker-py}}
\sphinxAtStartPar
The intent for this page is to show the functionality of the
\sphinxcode{\sphinxupquote{\_MarketData}} and \sphinxcode{\sphinxupquote{Equity}} classes, with a simple data query and
simulation run. The page is configured to run a Naive Monte Carlo
simulation with a normal random walk, and a historic price simulation
for comparison. The user puts in the ticker they want to evaluate, then
the server calls the following callbacks:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_data}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Creates a MarketData object by calling the Quandl API for a given
stock ticker from the \sphinxcode{\sphinxupquote{dash\_core\_components.Input}} labeled
‘stock’ and is called when the user hits the button labeled ‘Run’

\item {} 
\sphinxAtStartPar
Creates a simulation object from the MarketData and computes a
simulation and evaluates some metrics to be used later

\item {} 
\sphinxAtStartPar
Stores the data in hidden \sphinxcode{\sphinxupquote{\textless{}div\textgreater{}}} as a json object

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{chart}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Takes the queried MarketData, appends the forward steps of the
configured Monte Carlo simulation and plots it as a time series

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{monte\_carlo\_histogram}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Takes the evaluated simulation data and plots it as a histogram

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{summary\_table}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Takes the evaluated metrics and displays them as a HTML table

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Here is a screenshot of the output from the \sphinxcode{\sphinxupquote{get\_data}}, \sphinxcode{\sphinxupquote{chart}},
\sphinxcode{\sphinxupquote{monte\_carlo\_histogram}}, and \sphinxcode{\sphinxupquote{summary\_table}} call backs

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{aapl_marketdata}.png}
\caption{Time Series plot for AAPL Adjusted Closing Prices}\label{\detokenize{dashapp_documentation:id1}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{aapl_montecarlo_dist}.png}
\caption{Histogram plot for AAPL Monte Carlo Simulation}\label{\detokenize{dashapp_documentation:id2}}\end{figure}

\sphinxAtStartPar
Again, the HTML layout is defined by the defined layout object, that
contains the \sphinxcode{\sphinxupquote{dash}} components to render the HTML and JavaScript as
needed. In the future, this could be extended


\subsection{Portfolio Metrics \sphinxhyphen{} portfolio\_metrics.py}
\label{\detokenize{dashapp_documentation:portfolio-metrics-portfolio-metrics-py}}
\sphinxAtStartPar
The intent for this page is to show the functionality of the
\sphinxcode{\sphinxupquote{Portfolio}} class, which is a collection of \sphinxcode{\sphinxupquote{Equity}} object
instances. An extension of this project could be to extend the object
and run independent and correlated simulations as described in the
\sphinxhref{gettingstarted.rst\#\#parametrically-calculating-the-value-at-risk}{getting started
docs}.
The user uploads a portfolio from a csv file, then the page pulls all
the required data and evaluates the current value of the portfolio. When
uploaded, the following callbacks are called:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{output\_upload}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
When a portfolio csv is uploaded, then a \sphinxcode{\sphinxupquote{Portfolio}} object is
created and the underlying market data is queried.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{displayport}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Once the data is queried and stored, some simple metrics are
calculated and displayed in the HTML table

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Here is a screenshot of the upload element

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{portfolio_upload}.png}
\caption{Portfolio Upload and Template Download}\label{\detokenize{dashapp_documentation:id3}}\end{figure}

\sphinxAtStartPar
Here is the sample portfolio found in ‘./portfolio\_example.csv’

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{portfolio_valuation}.png}
\caption{HTML Table with Theoretical Portfolio Valuation}\label{\detokenize{dashapp_documentation:id4}}\end{figure}


\section{Summary}
\label{\detokenize{dashapp_documentation:summary}}
\sphinxAtStartPar
This lightweight application is not intended to be the only use of the
\sphinxcode{\sphinxupquote{risk\_dash}} framework, but to show the initial possibilities of using
an in memory risk engine that is lightweight enough to value simple and
complex securities.


\chapter{risk\_dash.securities}
\label{\detokenize{securities:module-risk_dash.securities}}\label{\detokenize{securities:risk-dash-securities}}\label{\detokenize{securities:securities}}\label{\detokenize{securities::doc}}\index{module@\spxentry{module}!risk\_dash.securities@\spxentry{risk\_dash.securities}}\index{risk\_dash.securities@\spxentry{risk\_dash.securities}!module@\spxentry{module}}\index{\_Security (class in risk\_dash.securities)@\spxentry{\_Security}\spxextra{class in risk\_dash.securities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities._Security}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{risk\_dash.securities.}}\sphinxbfcode{\sphinxupquote{\_Security}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{market\_data}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{market_data:risk_dash.market_data._MarketData}]{\sphinxcrossref{risk\_dash.market\_data.\_MarketData}}}}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Template for \_Security subclasses
\index{get\_marketdata() (risk\_dash.securities.\_Security method)@\spxentry{get\_marketdata()}\spxextra{risk\_dash.securities.\_Security method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities._Security.get_marketdata}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_marketdata}}}{}{}
\sphinxAtStartPar
Helper function to return market\_data attribute
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
self.market\_data

\end{description}\end{quote}

\end{fulllineitems}

\index{mark\_to\_market() (risk\_dash.securities.\_Security method)@\spxentry{mark\_to\_market()}\spxextra{risk\_dash.securities.\_Security method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities._Security.mark_to_market}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mark\_to\_market}}}{\emph{\DUrole{n}{current\_price}}}{}
\sphinxAtStartPar
Function to value current \_Security with current prices, marking the value to current prices
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{current\_price}} \textendash{} float, represents the current price for the \_Security

\item[{Returns}] \leavevmode
\sphinxAtStartPar
float, the value of the \_Security at current market price

\end{description}\end{quote}

\end{fulllineitems}

\index{simulate() (risk\_dash.securities.\_Security method)@\spxentry{simulate()}\spxextra{risk\_dash.securities.\_Security method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities._Security.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{\DUrole{n}{SimulationGenerator}}, \emph{\DUrole{n}{periods\_forward}}, \emph{\DUrole{n}{number\_of\_simulations}}}{}
\sphinxAtStartPar
Function to run simulation on a \_Security based level

\end{fulllineitems}

\index{valuation() (risk\_dash.securities.\_Security method)@\spxentry{valuation()}\spxextra{risk\_dash.securities.\_Security method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities._Security.valuation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valuation}}}{\emph{\DUrole{n}{price}}}{}
\sphinxAtStartPar
Function to return the value of \_Security at a given price
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{price}} \textendash{} float, the price to value the \_Security

\item[{Returns}] \leavevmode
\sphinxAtStartPar
float, the value of the \_Security given price

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Equity (class in risk\_dash.securities)@\spxentry{Equity}\spxextra{class in risk\_dash.securities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Equity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{risk\_dash.securities.}}\sphinxbfcode{\sphinxupquote{Equity}}}{\emph{\DUrole{n}{ticker}}, \emph{\DUrole{n}{market\_data}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{market_data:risk_dash.market_data.QuandlStockData}]{\sphinxcrossref{risk\_dash.market\_data.QuandlStockData}}}}}, \emph{\DUrole{n}{ordered\_price}}, \emph{\DUrole{n}{quantity}}, \emph{\DUrole{n}{date\_ordered}}}{}
\sphinxAtStartPar
The Equity class represents an equity position in a publically traded company
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ticker}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{market\_data}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ordered\_price}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{quantity}} \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{date\_ordered}} \textendash{} 

\end{itemize}

\end{description}\end{quote}
\index{mark\_to\_market() (risk\_dash.securities.Equity method)@\spxentry{mark\_to\_market()}\spxextra{risk\_dash.securities.Equity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Equity.mark_to_market}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mark\_to\_market}}}{\emph{\DUrole{n}{current\_price}}}{}
\sphinxAtStartPar
Returns the current value of the Equity given current price
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{current\_price}} \textendash{} float, represents the current price of the Equity Security

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the value of the Equity at current market prices

\end{description}\end{quote}

\end{fulllineitems}

\index{simulate() (risk\_dash.securities.Equity method)@\spxentry{simulate()}\spxextra{risk\_dash.securities.Equity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Equity.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{\DUrole{n}{SimulationGenerator}}, \emph{\DUrole{n}{periods\_forward}}, \emph{\DUrole{n}{number\_of\_simulations}}}{}
\sphinxAtStartPar
Function to run simulation at the Equity based level

\end{fulllineitems}

\index{valuation() (risk\_dash.securities.Equity method)@\spxentry{valuation()}\spxextra{risk\_dash.securities.Equity method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Equity.valuation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{valuation}}}{\emph{\DUrole{n}{price}}}{}
\sphinxAtStartPar
Returns value of the Equity given price input. Equity value is linear depending on a buy or sell, multiplied by the quantity of the position
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{price}} \textendash{} float, represents a given price

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the value of the Equity at a given price

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Portfolio (class in risk\_dash.securities)@\spxentry{Portfolio}\spxextra{class in risk\_dash.securities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{risk\_dash.securities.}}\sphinxbfcode{\sphinxupquote{Portfolio}}}{\emph{\DUrole{n}{securities}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_input}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{apikey}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
The Portfolio class handles interactions with the portfolio data and the associated securities in the portfolio.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{securities}} \textendash{} list of \_Security objects or None, if None, the object will try to create the port attribute using other data, if a list it will use the list of \_Security objects

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_input}} \textendash{} pandas.DataFrame, str, or None. If None and securities is None, no port attribute will be made and be an empty portfolio. Either pandas DataFrame or string path to a portfolio matching ‘./portfolio\_example.csv’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{apikey}} \textendash{} str, ApiKey for the market data object

\end{itemize}

\end{description}\end{quote}
\index{add\_security() (risk\_dash.securities.Portfolio method)@\spxentry{add\_security()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.add_security}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_security}}}{\emph{\DUrole{n}{security}}, \emph{\DUrole{n}{overwrite}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Helper function to add \_Security object to port attribute
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{security}} \textendash{} \_Security, \_Security object to add to port dictionary

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_portfolio\_returns() (risk\_dash.securities.Portfolio method)@\spxentry{calculate\_portfolio\_returns()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.calculate_portfolio_returns}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_portfolio\_returns}}}{\emph{\DUrole{n}{market\_data}}}{}
\sphinxAtStartPar
Calculates market data returns from flat prices
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{market\_data}} \textendash{} the market\_data variable with a flat price values

\item[{Returns}] \leavevmode
\sphinxAtStartPar
the market\_data variable with log returns

\end{description}\end{quote}

\end{fulllineitems}

\index{construct\_portfolio\_csv() (risk\_dash.securities.Portfolio method)@\spxentry{construct\_portfolio\_csv()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.construct_portfolio_csv}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{construct\_portfolio\_csv}}}{\emph{\DUrole{n}{data\_input}}, \emph{\DUrole{n}{apikey}}}{}
\sphinxAtStartPar
Built in portfolio constructor method
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data\_input}} \textendash{} either pandas DataFrame or string path to a portfolio matching ‘./portfolio\_example.csv’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{apikey}} \textendash{} ApiKey for the market data object

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
dict for self.port

\end{description}\end{quote}

\end{fulllineitems}

\index{drawdown() (risk\_dash.securities.Portfolio method)@\spxentry{drawdown()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.drawdown}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{drawdown}}}{\emph{\DUrole{n}{market\_data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{returns}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{key}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}adj\_close\textquotesingle{}}}}{}
\sphinxAtStartPar
Calculate Draw Down, the previous peak to current trough, through the historic market data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{market\_data}} \textendash{} DataFrame, the portfolio level market\_data. Use if made external changes to the market\_data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{returns}} \textendash{} Bool, True if calculate DD based on continuous returns, False if on level prices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} \textendash{} string, corresponds to the market\_data column to be calculated

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
DataFrame representing the Draw Down for the portfolio and components

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_date() (risk\_dash.securities.Portfolio method)@\spxentry{get\_date()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.get_date}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_date}}}{}{}
\sphinxAtStartPar
Grab the security with the most dates.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
returns a DatetimeIndex to construct a shared portfolio market\_data DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_last\_shared\_date() (risk\_dash.securities.Portfolio method)@\spxentry{get\_last\_shared\_date()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.get_last_shared_date}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_last\_shared\_date}}}{}{}
\sphinxAtStartPar
Return the last shared date
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
DateTime object

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_port\_variance() (risk\_dash.securities.Portfolio method)@\spxentry{get\_port\_variance()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.get_port_variance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_port\_variance}}}{\emph{\DUrole{n}{recalc}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{confidence\_interval}\DUrole{o}{=}\DUrole{default_value}{0.39881763041638185}}, \emph{\DUrole{n}{var\_horizon}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{lookback\_periods}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{key}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Returns portfolio variance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{recalc}} \textendash{} bool, If True recalculate variance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{confidence\_interval}} \textendash{} float, The critical value to implement parametric VaR

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{var\_horizon}} \textendash{} int, how many days/periods forward the parametric VaR should be calculated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lookback\_periods}} \textendash{} int, how many days/periods backward to condition the underlying distribution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} \textendash{} string, corresponds to the market\_data column to be calculated

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
tuple: (float Var(Portfolio), float Parametric Portfolio V@R)

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_portfolio\_marketdata() (risk\_dash.securities.Portfolio method)@\spxentry{get\_portfolio\_marketdata()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.get_portfolio_marketdata}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_portfolio\_marketdata}}}{\emph{\DUrole{n}{key}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{recalc}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Returns self.market\_data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} \textendash{} If not set, use key to set market\_data

\item[{Returns}] \leavevmode
\sphinxAtStartPar
pandas DataFrame self.market\_data

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_weights() (risk\_dash.securities.Portfolio method)@\spxentry{get\_weights()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.get_weights}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_weights}}}{}{}
\sphinxAtStartPar
Returns self.weights
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
dict for each security weight

\end{description}\end{quote}

\end{fulllineitems}

\index{historic\_var() (risk\_dash.securities.Portfolio method)@\spxentry{historic\_var()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.historic_var}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{historic\_var}}}{\emph{\DUrole{n}{market\_data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{returns}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{key}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}adj\_close\textquotesingle{}}}, \emph{\DUrole{n}{confidence}\DUrole{o}{=}\DUrole{default_value}{2.5}}, \emph{\DUrole{n}{var\_horizon}\DUrole{o}{=}\DUrole{default_value}{10}}}{}
\sphinxAtStartPar
Calulate Value at Risk from the historic distrubtion
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{market\_data}} \textendash{} DataFrame, the portfolio level market\_data. Use if made external changes to the market\_data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{returns}} \textendash{} Bool, True if calculate DD based on continuous returns, False if on level prices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} \textendash{} string, corresponds to the market\_data column to be calculated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{confidence}} \textendash{} float, percentile in percentage to pass into np.percentile

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{var\_horizon}} \textendash{} int, how many days/periods forward the parametric VaR should be calculated

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
tuple, (DataFrame, market\_data, float, Historic VaR)

\end{description}\end{quote}

\end{fulllineitems}

\index{mark() (risk\_dash.securities.Portfolio method)@\spxentry{mark()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.mark}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mark}}}{}{}
\sphinxAtStartPar
Mark portfolio with current market prices, sets marked\_portfolio and market\_change.

\end{fulllineitems}

\index{quick\_plot() (risk\_dash.securities.Portfolio method)@\spxentry{quick\_plot()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.quick_plot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{quick\_plot}}}{\emph{\DUrole{n}{returns}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{key}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}adj\_close\textquotesingle{}}}, \emph{\DUrole{n}{plot}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{figsize}\DUrole{o}{=}\DUrole{default_value}{(5, 8)}}}{}
\sphinxAtStartPar
Quickly plot using matplotlib and pandas.plot()
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{returns}} \textendash{} Bool, True if calculate DD based on continuous returns, False if on level prices

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} \textendash{} string, corresponds to the market\_data column to be calculated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{plot}} \textendash{} Bool, if True, plot the data frame, if flase just return the market\_data DataFrame

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
DataFrame market\_data

\end{description}\end{quote}

\end{fulllineitems}

\index{remove\_security() (risk\_dash.securities.Portfolio method)@\spxentry{remove\_security()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.remove_security}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{remove\_security}}}{\emph{\DUrole{n}{security}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{security\_name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{security\_type}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Helper function to remove \_Security object from port attribute, either pass the object or name type string pair to remove from port dictionary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{security}} \textendash{} \_Security, \_Security object to remove

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{security\_name}} \textendash{} str, Name of the security for .port key, to match \_Security.name

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{security\_type}} \textendash{} str, String to match \_Security.type of the \_Security object to be removed

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_port\_variance() (risk\_dash.securities.Portfolio method)@\spxentry{set\_port\_variance()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.set_port_variance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_port\_variance}}}{\emph{\DUrole{n}{market\_data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{confidence\_interval}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1.9599639845400545}}, \emph{\DUrole{n}{var\_horizon}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{lookback\_periods}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{key}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}percentchange\textquotesingle{}}}}{}
\sphinxAtStartPar
Calulates parametric Variance by calculating Weight.T * Cov * Weight
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{market\_data}} \textendash{} DataFrame, the portfolio level market\_data. Use if made external changes to the market\_data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{confidence\_interval}} \textendash{} float, The critical value to implement parametric VaR

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{var\_horizon}} \textendash{} int, how many days/periods forward the parametric VaR should be calculated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lookback\_periods}} \textendash{} int, how many days/periods backward to condition the underlying distribution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} \textendash{} string, corresponds to the market\_data column to be calculated

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
float portfolio variance, standard deviation ** 2, float parametric value at risk

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_portfolio\_marketdata() (risk\_dash.securities.Portfolio method)@\spxentry{set\_portfolio\_marketdata()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.set_portfolio_marketdata}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_portfolio\_marketdata}}}{\emph{\DUrole{n}{key}}}{}
\sphinxAtStartPar
Combine individual market data into one pandas DataFrame.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{key}} \textendash{} Common column name for each security

\item[{Returns}] \leavevmode
\sphinxAtStartPar
pandas DataFrame containing columns for each security’s common market\_data

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_weights() (risk\_dash.securities.Portfolio method)@\spxentry{set\_weights()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.set_weights}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_weights}}}{}{}
\sphinxAtStartPar
Calculate value weighted portfolio.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
dict for each security weight

\end{description}\end{quote}

\end{fulllineitems}

\index{simulate() (risk\_dash.securities.Portfolio method)@\spxentry{simulate()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{\DUrole{n}{SimulationGenerator}}, \emph{\DUrole{n}{periods\_forward}}, \emph{\DUrole{n}{number\_of\_simulations}}}{}
\sphinxAtStartPar
Primary function to simulate the entire portfolio

\end{fulllineitems}

\index{value() (risk\_dash.securities.Portfolio method)@\spxentry{value()}\spxextra{risk\_dash.securities.Portfolio method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{securities:risk_dash.securities.Portfolio.value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{value}}}{}{}
\sphinxAtStartPar
Value current portfolio with current market prices.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
value of the portfolio

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{risk\_dash.market\_data}
\label{\detokenize{market_data:module-risk_dash.market_data}}\label{\detokenize{market_data:risk-dash-market-data}}\label{\detokenize{market_data:market-data}}\label{\detokenize{market_data::doc}}\index{module@\spxentry{module}!risk\_dash.market\_data@\spxentry{risk\_dash.market\_data}}\index{risk\_dash.market\_data@\spxentry{risk\_dash.market\_data}!module@\spxentry{module}}\index{\_MarketData (class in risk\_dash.market\_data)@\spxentry{\_MarketData}\spxextra{class in risk\_dash.market\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{market_data:risk_dash.market_data._MarketData}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{risk\_dash.market\_data.}}\sphinxbfcode{\sphinxupquote{\_MarketData}}}
\sphinxAtStartPar
Template for \_MarketData subclasses
\index{current\_price() (risk\_dash.market\_data.\_MarketData method)@\spxentry{current\_price()}\spxextra{risk\_dash.market\_data.\_MarketData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{market_data:risk_dash.market_data._MarketData.current_price}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{current\_price}}}{}{}
\sphinxAtStartPar
This should return the current market price, the price at the last available time period
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
float the market price

\end{description}\end{quote}

\end{fulllineitems}

\index{gather() (risk\_dash.market\_data.\_MarketData method)@\spxentry{gather()}\spxextra{risk\_dash.market\_data.\_MarketData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{market_data:risk_dash.market_data._MarketData.gather}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gather}}}{}{}
\sphinxAtStartPar
This should gather data from the source and store it into memory or dictate how to interact with the source
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
a pandas DataFrame, market\_data or other data type to interact with

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{QuandlStockData (class in risk\_dash.market\_data)@\spxentry{QuandlStockData}\spxextra{class in risk\_dash.market\_data}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{market_data:risk_dash.market_data.QuandlStockData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{risk\_dash.market\_data.}}\sphinxbfcode{\sphinxupquote{QuandlStockData}}}{\emph{\DUrole{n}{apikey}}, \emph{\DUrole{n}{ticker}}, \emph{\DUrole{n}{days}\DUrole{o}{=}\DUrole{default_value}{80}}}{}
\sphinxAtStartPar
\_MarketData class for Quandl’s WIKI/EOD price data base (\sphinxurl{https://www.quandl.com/databases/WIKIP})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{apikey}} \textendash{} string, a valid Quandl apikey

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ticker}} \textendash{} string, ticker symbol to query

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{days}} \textendash{} int, how many days back to use for rolling metrics

\end{itemize}

\end{description}\end{quote}
\index{current\_price() (risk\_dash.market\_data.QuandlStockData method)@\spxentry{current\_price()}\spxextra{risk\_dash.market\_data.QuandlStockData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{market_data:risk_dash.market_data.QuandlStockData.current_price}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{current\_price}}}{}{}
\sphinxAtStartPar
Returns the latest available market price
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
float, latest available market price

\end{description}\end{quote}

\end{fulllineitems}

\index{gather() (risk\_dash.market\_data.QuandlStockData method)@\spxentry{gather()}\spxextra{risk\_dash.market\_data.QuandlStockData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{market_data:risk_dash.market_data.QuandlStockData.gather}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gather}}}{}{}
\sphinxAtStartPar
Gathers the data from the Quandl api and returns a pandas DataFrame
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
pandas DataFrame

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_expected() (risk\_dash.market\_data.QuandlStockData method)@\spxentry{set\_expected()}\spxextra{risk\_dash.market\_data.QuandlStockData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{market_data:risk_dash.market_data.QuandlStockData.set_expected}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_expected}}}{\emph{\DUrole{n}{days}}}{}
\sphinxAtStartPar
Calculate exponentially and simply weighted rolling averages
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{days}} \textendash{} int, look back days to compute rolling averages

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_price\_changes() (risk\_dash.market\_data.QuandlStockData method)@\spxentry{set\_price\_changes()}\spxextra{risk\_dash.market\_data.QuandlStockData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{market_data:risk_dash.market_data.QuandlStockData.set_price_changes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_price\_changes}}}{}{}
\sphinxAtStartPar
Set daily price changes and logged percent changes

\end{fulllineitems}

\index{set\_volatility() (risk\_dash.market\_data.QuandlStockData method)@\spxentry{set\_volatility()}\spxextra{risk\_dash.market\_data.QuandlStockData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{market_data:risk_dash.market_data.QuandlStockData.set_volatility}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_volatility}}}{\emph{\DUrole{n}{days}}}{}
\sphinxAtStartPar
Calculate exponentially and simply weighted rolling standard deviations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{days}} \textendash{} int, look back days to compute rolling std deviation

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{risk\_dash.simgen}
\label{\detokenize{simulation:module-risk_dash.simgen}}\label{\detokenize{simulation:risk-dash-simgen}}\label{\detokenize{simulation:simgen}}\label{\detokenize{simulation::doc}}\index{module@\spxentry{module}!risk\_dash.simgen@\spxentry{risk\_dash.simgen}}\index{risk\_dash.simgen@\spxentry{risk\_dash.simgen}!module@\spxentry{module}}\index{\_RandomGen (class in risk\_dash.simgen)@\spxentry{\_RandomGen}\spxextra{class in risk\_dash.simgen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:risk_dash.simgen._RandomGen}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{risk\_dash.simgen.}}\sphinxbfcode{\sphinxupquote{\_RandomGen}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Abstract class for a Random Variable Generator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} \textendash{} dict, a collection of necessary arguments to specify the RV distribution. See .NormalDistribution for an example

\end{description}\end{quote}
\index{generate() (risk\_dash.simgen.\_RandomGen method)@\spxentry{generate()}\spxextra{risk\_dash.simgen.\_RandomGen method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:risk_dash.simgen._RandomGen.generate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{generate}}}{\emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Function to generate random values given the RV distribution or other method of generating values

\end{fulllineitems}


\end{fulllineitems}

\index{\_Simulation (class in risk\_dash.simgen)@\spxentry{\_Simulation}\spxextra{class in risk\_dash.simgen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:risk_dash.simgen._Simulation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{risk\_dash.simgen.}}\sphinxbfcode{\sphinxupquote{\_Simulation}}}{\emph{\DUrole{n}{Generator}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{simulation:risk_dash.simgen._RandomGen}]{\sphinxcrossref{risk\_dash.simgen.\_RandomGen}}}}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Abstract class to create a simulation given a Random Variable Generator
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Generator}} \textendash{} \_RandomGen, the RV distribution to use for a given simulation. See .NaiveMonteCarlo for an example

\end{description}\end{quote}
\index{set\_var() (risk\_dash.simgen.\_Simulation method)@\spxentry{set\_var()}\spxextra{risk\_dash.simgen.\_Simulation method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:risk_dash.simgen._Simulation.set_var}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_var}}}{\emph{\DUrole{n}{percentile}\DUrole{o}{=}\DUrole{default_value}{2.5}}}{}
\sphinxAtStartPar
Helper function to set Value at Risk given a certain percentile
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{percentile}} \textendash{} float, default 2.5, represents the Value at Risk, as defined by a certain percentile, for a simulation

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{NormalDistribution (class in risk\_dash.simgen)@\spxentry{NormalDistribution}\spxextra{class in risk\_dash.simgen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:risk_dash.simgen.NormalDistribution}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{risk\_dash.simgen.}}\sphinxbfcode{\sphinxupquote{NormalDistribution}}}{\emph{\DUrole{n}{location}}, \emph{\DUrole{n}{scale}}}{}
\sphinxAtStartPar
A \_RandomGen object that represents a normal/Gaussian. See {[}numpy documentation{]}(\sphinxurl{https://numpy.org/doc/stable/reference/random/generated/numpy.random.normal.html}) for more detail
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{location}} \textendash{} float, the mean/center of the distribution

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scale}} \textendash{} float, the standard deviation of the distribution. Must be non\sphinxhyphen{}negative.

\end{itemize}

\end{description}\end{quote}
\index{generate() (risk\_dash.simgen.NormalDistribution method)@\spxentry{generate()}\spxextra{risk\_dash.simgen.NormalDistribution method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:risk_dash.simgen.NormalDistribution.generate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{generate}}}{\emph{\DUrole{n}{obs}}}{}
\sphinxAtStartPar
Function to return a numpy.array of parametrically defined normally distributed random values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{obs}} \textendash{} int, number of values to be generated

\item[{Returns}] \leavevmode
\sphinxAtStartPar
numpy.array of numpy.float, represents a collection of randomly distributed values

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{NaiveMonteCarlo (class in risk\_dash.simgen)@\spxentry{NaiveMonteCarlo}\spxextra{class in risk\_dash.simgen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:risk_dash.simgen.NaiveMonteCarlo}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{risk\_dash.simgen.}}\sphinxbfcode{\sphinxupquote{NaiveMonteCarlo}}}{\emph{\DUrole{n}{Generator}\DUrole{p}{:} \DUrole{n}{{\hyperref[\detokenize{simulation:risk_dash.simgen._RandomGen}]{\sphinxcrossref{risk\_dash.simgen.\_RandomGen}}}}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
A \_Simulation object to create a Naive Monte Carlo simulation of a Random Walk, with each step being i.i.d. given the \_RandomGen RV Generator class
\index{simulate() (risk\_dash.simgen.NaiveMonteCarlo method)@\spxentry{simulate()}\spxextra{risk\_dash.simgen.NaiveMonteCarlo method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{simulation:risk_dash.simgen.NaiveMonteCarlo.simulate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulate}}}{\emph{\DUrole{n}{periods\_forward}}, \emph{\DUrole{n}{number\_of\_simulations}}}{}
\sphinxAtStartPar
Function to simulate each independent walk in the Monte Carlo simulation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{periods\_forward}} \textendash{} int, how many steps into the future each random simulated random walk will take

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{number\_of\_simulations}} \textendash{} int, how many separate independent paths will be simulated

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
np.array of shape (periods\_forward, number\_of\_simulations), each row is an independent simulation, each column is a time period step

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Software License}
\label{\detokenize{license:software-license}}\label{\detokenize{license:license}}\label{\detokenize{license::doc}}
\sphinxAtStartPar
MIT License

\sphinxAtStartPar
Copyright (c) 2018 Alexander Henk van Oene

\sphinxAtStartPar
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
“Software”), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

\sphinxAtStartPar
The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

\sphinxAtStartPar
THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{r}
\item\relax\sphinxstyleindexentry{risk\_dash.market\_data}\sphinxstyleindexpageref{market_data:\detokenize{module-risk_dash.market_data}}
\item\relax\sphinxstyleindexentry{risk\_dash.securities}\sphinxstyleindexpageref{securities:\detokenize{module-risk_dash.securities}}
\item\relax\sphinxstyleindexentry{risk\_dash.simgen}\sphinxstyleindexpageref{simulation:\detokenize{module-risk_dash.simgen}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}