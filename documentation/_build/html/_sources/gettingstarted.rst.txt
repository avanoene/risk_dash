.. _gettingstarted:
 
risk_dash Overview and Getting Started
======================================

-  `risk_dash Overview and Getting
   Started <#risk_dash-overview-and-getting-started>`__

   -  `Overview <#overview>`__
   -  `Installation <#installation>`__
   -  `Getting Started <#getting-started>`__

      -  `Security data, Security objects, and creating Security
         Subclasses <#security-data-security-objects-and-creating-security-subclasses>`__
      -  `Portfolio Data and creating a
         Portfolio <#portfolio-data-and-creating-a-portfolio>`__
      -  `Calculating Risk Metrics and Using the Portfolio
         class <#calculating-risk-metrics-and-using-the-portfolio-class>`__

         -  `Marking the Portfolio <#marking-the-portfolio>`__
         -  `Parametrically Calculating the Value at
            Risk <#parametrically-calculating-the-value-at-risk>`__

      -  `Simulating the Portfolio <#simulating-the-portfolio>`__

         -  `Simulating a Unit Resolution
            Distribution <#simulating-a-unit-resolution-distribution>`__
         -  `Simulating a Path
            Distribution <#simulating-a-path-distribution>`__

      -  `Summary <#summary>`__

Overview
--------

`risk_dash <https://github.com/avanoene/risk_dash>`__ is a framework to
help formalize the data flow for a portfolio of assets and handle market
risk metrics at the asset and portfolio level. If you clone the source
`repository <https://github.com/avanoene/risk_dash>`__, included is a
`Dash <https://plot.ly/dash/>`__ application to be an example of some of
the uses for the package. To run the Dash app, documentation is
`here <dashapp_documentation.rst#risk_dash-dash-application-documentation>`__

Installation
------------

Since the package is in heavy development, to install the package fork
or clone the `repository <https://github.com/avanoene/risk_dash>`__ and
run ``pip install -e risk_dash/`` from the directory above your local
repository.

To see if installation was successful run
``python -c 'import risk_dash; print(*dir(risk_dash), sep="\n")'`` in
the command line, currently the output should match the following:

.. code:: bash

   $ python -c 'import risk_dash; print(*dir(risk_dash), sep="\n")'
   __builtins__
   __cached__
   __doc__
   __file__
   __loader__
   __name__
   __package__
   __path__
   __spec__
   market_data
   name
   securities
   simgen

Getting Started
---------------

Now that we have the package installed, let’s go through the object
workflow to construct a simple long/short equity portfolio.

From a high level, we need to specify:

1. Portfolio Data

   -  We need to know what’s in the portfolio

      -  Portfolio weights
      -  Types of Assets/Securities

2. Security data

   -  We need to know what is important to financially model the
      security

      -  Identification data: Ticker, CUSIP, Exchange
      -  Security specific data: expiry, valuation functions
      -  Market data: Closing prices, YTM

3. Portfolio/security constructors to handle the above data

To visualize these constructors, the below chart shows how the data will
sit:

|image1|

To do so, we’ll need subclasses for the ``_Security`` and
``_MarketData`` classes to model specific types of securities. Currently
supported is the Equity subclass. Once we have the portfolio
constructed, we will specify and calculate parameters to simulate or
look at historic distributions. We’ll then create a subclass of
``_Simulation`` and ``_RandomGen``.

Security data, Security objects, and creating Security Subclasses
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The core of the package is in the ``_Security`` and ``Portfolio``
objects. ``Portfolio`` objects are naturally a collection of Securities,
however we want to specify the type of securities that are in the
portfolio. Since we’re focusing on a long/short equity portfolio we want
to create an Equity subclass.

Subclasses of ``_Security`` classes must have the following methods:

-  valuation(current_price)
-  mark_to_market(current_price)
-  get_marketdata()

In addition, we want to pass them the associated ``_MarketData`` object
to represent the security’s historic pricing data. To build the
``Equity`` subclass, we first want to inherit any methods from the
``_Security`` class:

.. code:: python

   class Equity(_Security):

       def __init__(
               self,
               ticker,
               market_data : md.QuandlStockData,
               ordered_price,
               quantity,
               date_ordered
           ):
           self.name = ticker
           self.market_data = market_data
           self.ordered_price = ordered_price
           self.quantity = quantity
           self.initial_value = ordered_price * quantity
           self.date_ordered = date_ordered
           self.type = 'Equity'

To break down the inputs, we want to keep in mind that the goal of this
subclass of the ``_Security`` object is to provide an interface to model
the Equity data.

-  ticker is going to be the ticker code for the equity, such as ‘AAPL’
-  market_data is going to be a subclass of the ``_MarketData`` object
-  ordered_price is going to be the price which the trade occurred
-  quantity for Equity will be the number of shares
-  date_ordered should be the date the order was placed

..

   Note: Currently the implemented ``_MarketData`` subclass is
   ``QuandlStockData``, which is a wrapper for `this Quandl dataset
   api <https://www.quandl.com/databases/WIKIP>`__. This data is no
   longer being updated, for current market prices you must create a
   \_MarketData subclass for your particular market data.

Required Inputs at the ``_Security`` level are intentionally limited,
for example if we wanted to create a class for Fixed Income securities,
we would want more information than this Equity subclass. An example
Bond class might look like this:

.. code:: python

   class Bond(_Security):
       def __init__(
               self,
               CUSIP,
               market_data,
               expiry,
               coupon,
               frequency,
               settlement_date,
               face_value
           ):
           self.name = CUSIP
           self.market_data = market_data
           self.expiry = expiry
           self.coupon = coupon
           self.frequency = frequency
           self.settlement_date = settlement_date
           self.face_value = face_value
           self.type = 'Bond'

Similarly to the ``Equity`` subclass, we want identification
information, market data, and arguments that will either help in
calculating valuation, current returns, or risk measures.

Returning to the ``Equity`` subclass, we now need to write the valuation
and mark to market methods:

.. code:: python

   class Equity(_Security):
     # ...
     def valuation(self, price):
         value = (price - self.ordered_price) * self.quantity
         return(value)

     def mark_to_market(self, current_price):
         self.market_value = self.quantity * current_price
         self.marked_change = self.valuation(current_price)
         return(self.marked_change)

For linear instruments such as equities, valuation of a position is just
the price observed minus the price ordered at the size of the position.
The ``valuation`` method is then used to pass a hypothetical price into
the valuation function, in this case (Price - Ordered) \* Quantity,
where as ``mark_to_market`` method is used to pass the current EOD price
and mark the value of the position. This is an important distinction, if
we had a nonlinear instrument such as a call option on a company’s
equity price, the valuation function would then be:

.. math::


   Value = min\{0, S_{T} - K\}

Where :math:`S_{T}` is the spot price for the equity at expiry and
:math:`K` is the strike price of the call option contract. Valuation
also is dependent on time for option data, however if you were to use a
binomial tree to evaluate the option, you would want to use this same
value function and discount the value a each node back to time=0.

Our mark to market then would need to make the distinction between this
valuation and the current market price for the call option. The mark
would then keep track of what the current market value for the option to
keep track of actualized returns.

The final piece to creating the Equity subclass is then to add a
``get_marketdata()``\ method. Since we just want a copy of the reference
of the ``market_data``, we can just inherit the ``get_marketdata()``
from the ``_Security`` parent class.

The ``Equity`` subclass is already implemented in the package, we can
create an instance from ``risk_dash.securities``. Let’s make an instance
that represents an order of 50 shares of AAPL, Apple Inc, at close on
March 9th, 2018:

.. code:: python

   >>> from risk_dash.market_data import QuandlStockData
   >>> from risk_dash.securities import Equity
   >>> from datetime import datetime
   >>> apikey = 'valid-quandl-apikey'
   >>> aapl_market_data = QuandlStockData(
     apikey = apikey,
     ticker = 'AAPL'
   )
   >>> aapl_stock = Equity(
     ticker = 'AAPL',
     market_data = aapl_market_data,
     ordered_price = 179.98,
     quantity = 50,
     date_ordered = datetime(2018,3,9)
   )
   >>> aapl_stock.valuation(180.98) # $1 increase in value
   50.0
   >>> aapl_stock.mark_to_market(180.98) # Same $1 increase
   50.0
   >>> aapl_stock.market_value
   9049.0
   >>> aapl_stock.marked_change
   50.0
   >>> vars(aapl_stock)
   {'name': 'AAPL',
    'market_data': <risk_dash.market_data.QuandlStockData at 0x1147c2668>,
    'ordered_price': 179.98,
    'quantity': 50,
    'initial_value': 8999.0,
    'date_ordered': datetime.datetime(2018, 3, 9, 0, 0),
    'type': 'Equity',
    'market_value': 9049.0,
    'marked_change': 50.0}

As we can see ``aapl_stock`` now is a container that we can use to
access it’s attributes at the ``Portfolio`` level.

   Note: Another important observation is that the ``Equity`` subclass
   will only keep a reference to the underlying ``QuandlStockData``,
   which will minimize duplication of data. However, at scale, you’d
   want minimize price calls to your data source, you could then do one
   call at the ``Portfolio`` level then pass a reference to that
   market_data at the individual level. Then your ``Equity`` or other
   ``_Security`` subclasses can share the same ``_MarketData``, you
   would then just write methods to interact with that data.

Now that we have a feeling for the ``_Security`` class, we now want to
build a Portfolio that contains the ``_Security`` instances.

Portfolio Data and creating a Portfolio
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To iterate on what we said before, an equity position in your portfolio
is represented by the quantity you ordered, the price ordered at, and
when you ordered or settled the position. In this example, we’ll use the
following theoretical portfolio found in ``portfolio_example.csv``:

====== ====== ============= ============ ========
Type   Ticker Ordered Price Ordered Date Quantity
====== ====== ============= ============ ========
Equity AAPL   179.98        3/9/18       50
Equity AMD    11.7          3/9/18       100
Equity INTC   52.19         3/9/18       -50
Equity GOOG   1160.04       3/9/18       5
====== ====== ============= ============ ========

With this example, the portfolio is static, or just one snap shot of the
weights at a given time. In practice, it might be useful to have
multiple snapshots of your portfolio, one’s portfolio would be changing
as positions enter and leave thus having a time dimensionality. The
Portfolio class could be easily adapted to handle that information to
accurately plot historic performance by remarking through time. This
seems more of an accounting exercise, risk metrics looking forward would
probably still only want to account for the current positions in the
portfolio. Due to this insight, the current Portfolio class only looks
at one snap shot in time.

With a portfolio so small, it is very easily stored in a csv and each
security can store the reference to the underlying market data
independently. As such, there is an included portfolio constructor
method in the portfolio class from csv, ``construct_portfolio_csv``:

.. code:: python

   >>> from risk_dash.securities import Portfolio
   >>> current_portfolio = Portfolio()
   >>> port_dict = current_portfolio.construct_portfolio_csv(
     data_input='portfolio_example.csv',
     apikey=apikey
   )
   >>> vars(current_portfolio)
   {'port': {'AAPL Equity': <risk_dash.securities.Equity at 0x11648b5c0>,
     'AMD Equity': <risk_dash.securities.Equity at 0x116442c50>,
     'INTC Equity': <risk_dash.securities.Equity at 0x1177b75c0>,
     'GOOG Equity': <risk_dash.securities.Equity at 0x1177bc390>}}
   >>> vars(current_portfolio.port['AMD Equity'])
   {'name': 'AMD',
    'market_data': <risk_dash.market_data.QuandlStockData at 0x11648b2e8>,
    'ordered_price': 11.699999999999999,
    'quantity': 100,
    'initial_value': 1170.0,
    'date_ordered': '3/9/18',
    'type': 'Equity'}

At this moment, the ``current_portfolio`` instance is only a wrapper for
it’s ``port`` attribute, a dictionary containing the securities in the
``Portfolio`` object. Soon we’ll use this object to mark the portfolio,
create a simulation to estimate value at risk, look at the covariance
variance matrix to calculate a parameterized volatility measure, and
much more.

The ``Portfolio`` class handles interactions with the portfolio data and
the associated securities in the portfolio. If you have a list of
securities you can also just pass the list into the ``Portfolio``
instance. The following code creates a portfolio of just the AAPL equity
that we created earlier:

.. code:: python

   >>> aapl_portfolio = sec.Portfolio([aapl_stock])
   >>> vars(aapl_portfolio)
   {'port': {'AAPL Equity': <risk_dash.securities.Equity at 0x1164b2e80>}}

If we want to add a security to this portfolio, we can call the
``add_security`` method, to remove a security we call the
``remove_security`` method:

.. code:: python

   >>> amd_market_data = QuandlStockData(
     ticker='AMD',
     apikey=apikey
   )
   >>> amd_stock = Equity(
     ticker = 'AAPL',
     market_data = amd_market_data,
     ordered_price = 11.70,
     quantity = 100,
     date_ordered = datetime(2018,3,9)
   )
   >>> aapl_portfolio.add_security(amd_stock)
   >>> aapl_portfolio.port
   {'AAPL Equity': <risk_dash.securities.Equity at 0x1164b2e80>,
    'AMD Equity': <risk_dash.securities.Equity at 0x11791cc88>}
   >>> aapl_portfolio.remove_security(amd_stock)
   >>> aapl_portfolio.port
   {'AAPL Equity': <risk_dash.securities.Equity at 0x1164b2e80>}
   >>> aapl_portfolio.remove_security(aapl_stock)
   >>> aapl_portfolio.port
   {}

Calculating Risk Metrics and Using the Portfolio class
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that we have our ``Portfolio`` constructed with the securities we
have on the book, let’s use the class to calculate some market risk
metrics.

Marking the Portfolio
^^^^^^^^^^^^^^^^^^^^^

Let’s first mark the current portfolio. Since we want to know the
current value of the portfolio, the mark method will calculate the value
of the portfolio at the current price for each security. The current
price is going to be the last known mark, the price at the closest date
to today.

   Note: Since the ``QuandlStockData`` source hasn’t been updated since
   3/27/2018, we would expect the last shared date to be 3/27/2018.
   However, you should use the last shared date as a flag to see if an
   asset’s ``_MarketData`` isn’t updating. With certain assets, such as
   Bonds or illiquid securities, marking daily might not make as much
   sense, so common shared date doesn’t mean as much.

.. code:: python

   >>> current_portfolio.mark()
   >>> vars(current_portfolio)
   {'port': {'AAPL Equity': <risk_dash.securities.Equity at 0x10f8b2940>,
     'AMD Equity': <risk_dash.securities.Equity at 0x1a1f6b0908>,
     'INTC Equity': <risk_dash.securities.Equity at 0x110538d30>,
     'GOOG Equity': <risk_dash.securities.Equity at 0x110548e10>},
    'market_change': -1476.6999999999989,
    'marked_portfolio': {'AAPL Equity': (8999.0, 8417.0),
     'AMD Equity': (1170.0, 1000.0),
     'INTC Equity': (-2609.5, -2559.5),
     'GOOG Equity': (5800.1999999999998, 5025.5)},
    'date_marked': Timestamp('2018-03-27 00:00:00'),
    'initial_value': 13359.700000000001}

The ``mark`` method now creates the ``marked_portfolio`` dictionary that
stores a tuple, (initial_value, market_value), for every security in the
portfolio. We also now can calculate a quick holding period return:

.. code:: python

   >>> holdingreturn = (current_portfolio.market_change)/current_portfolio.initial_value
   >>> print(holdingreturn)
   -0.11053391917483169

This hypothetical portfolio apparently hasn’t performed over the month
since inception, it’s lost 11%, but let’s look at historic returns
before we give up on the portfolio. We can call ``portfolio.quick_plot``
to look at a ``matplotlib`` generated cumulative return series of the
portfolio. If you wanted more control over plotting, you could use the
returned ``pandas DataFrame``. In fact, the current implementation is
just using the ``pandas DataFrame`` method ``plot()``:

.. code:: python

   >>> marketdata = current_portfolio.quick_plot()

.. figure:: ./quick_plot_image.png
   :alt: quick_plot() Output

   quick_plot() Output

Parametrically Calculating the Value at Risk
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As we can see, this portfolio is pretty volatile, but has almost doubled
over the last four years. Let’s calculate what the portfolio daily
volatility over the period based off the percent change by calling
``get_port_volatility`` using ``percentchange`` from the
``market_data``:

.. code:: python

   >>> variance, value_at_risk = current_portfolio.set_port_variance(
     key = 'percentchange'
   )
   >>> volatility = np.sqrt(variance)
   >>> print(volatility)
   0.01345831069378136
   >>> mean = np.mean(current_portfolio.market_data['portfolio'])
   >>> print(mean)
   0.0007375242310493472

We calculated 1.3% daily standard deviation or daily volatility, if the
distribution is normally distributed around zero, then we would expect
that 95% of the data is contained within approximately 2 standard
deviations. We can visually confirm, as well as look to see if there are
other distributional aspects we can visually distinguish:

.. code:: python

   >>> import matplotlib.pyplot as plt
   >>> marketdata['portfolio'].plot.hist(bins=20,title='Portfolio Historic Returns')
   >>> plt.axvline(temp * 1.96, color='r', linestyle='--') # if centered around zero, then
   >>> plt.axvline(-temp * 1.96, color='r', linestyle='--') #

.. figure:: ./portfolio_returns.png
   :alt: Portfolio Returns

   Portfolio Returns

This distribution looks highly centered around zero, which could signal
kurtosis. This seems indicative of equity data, especially for daily
returns. Right now, a good place to start thinking about metric
parameterization is to assume normality and independence in daily
returns. While this assumption might not be very good or might vary
between security to security in the portfolio, which we can account for
in simulation or purely using historic returns to calculate risk
metrics, we can use this distribution assumption to quickly get a Value
at Risk metric over a time horizon.

The default time horizon is 10 days at a 95% confidence level for the
``set_port_variance`` method, so if we look at the returned
``value_at_risk``:

.. code:: python

   >>> print(value_at_risk)
   -0.083413941112170473

This value is simply the standard deviation scaled by time, at the
critical value specified:

.. math::


   VaR_{t, T} = \sigma \cdot \sqrt{T-t} \cdot Z^{*}_{p = \alpha}

We can interpret this Value at Risk as being the lower bound of the 95%
confidence interval for the 10 day distribution. For this portfolio, on
average, a loss over 10 days less than 8.3% should occur 2.5% of the
time. To get the dollar value of the 10 Day Value at Risk, we would just
multiply this percent change by the current portfolio market value.

.. code:: python

   >>> dollar_value_at_risk = value_at_risk * (current_portfolio.initial_value + current_portfolio.marked_change)
   >>> print(dollar_value_at_risk)
   -991.20786223592188

Similarly, we could interpret as over the a 10 day period, on average,
2.5% of the time there could be an approximate loss over $991.21 dollars
for this portfolio. However, this is relying on the assumption that the
portfolio is: a) normally distributed, and b) daily returns are serially
independent and identically distributed. One way we can go around this
is to look at the historic distribution

.. code:: python

   >>> historic_distribution, historic_var = current_portfolio.historic_var()
   >>> print(historic_var)
   -0.073051970330112487

This is calculated by doing a cumulative sum of returns over each
horizon time period, then taking the appropriate percentile of the
distribution to get a VaR based on historic prices. This is is smaller
than the parametric VaR due to the fact that the distribution looks more
right skewed as shown below

.. figure:: ./historic_10_return.png
   :alt: Historic 10D VaR

   Historic 10D VaR

This method is fairly simple, however it is based on the assumption that
the previous distribution of outcomes is a good representation of the
future distribution.

Another way we’ve implemented to calculate the value at risk is to
simulate the portfolio distribution.

Simulating the Portfolio
~~~~~~~~~~~~~~~~~~~~~~~~

When simulating portfolio returns, one’s objective is to correctly
specify the portfolio distribution. I consider two major approaches,
“bottom-up” and “top-down”.

The “bottom-up” approach would include simulating the underlying
securities first and then valuing the portfolio through the simulated
distributions. The major strength of this method is the ability to
easily value the effect of derivative securities on the portfolio. Since
one would simulate the derivative’s underlier, you could easily then
apply the associated value function through the simulated distribution
to get the security’s profit and loss distribution. Another benefit to
this methodology is the analyst has the freedom to change the simulation
process at a security level. General Brownian motion might be a good
assumption for long/short equity positions, but maybe not as good when
simulating yield curves for bonds. Another strength would be the ability
to change portfolio weights of securities post simulation, if you
simulate a base unit of the security you could then scale the weights
accordingly to easily reweigh the portfolio. The biggest challenge to
this methodology is to ensure that each simulation value represents the
same market environment, meaning that each simulation pull represents
the same environment state. While you can potentially do a convolution
of the different simulations to get a representative joint distribution
of the portfolio, you must ensure that one is capturing the covariance
between the securities. For example, equities and bonds have
historically had negative correlation to each other, thus a portfolio
containing both would potentially have a lower variance than each
security separate. To capture that in a simulation one would have to
simulate directly from the variance-covariance matrix or do a
convolution to combine separate simulations together. While both are
possible, and in practice it is probably a preferred methodology,
however it’s not within the scope of this project.

The “top-down” approach would include aggregating the portfolio a priori
and then simulating that distribution. Since the portfolio is made of
the member securities, thus the aggregated distribution represents all
covariance. While this method gets a little be trickier to handle with
derivative securities, since you would need historic market prices per
contract and potentially roll adjust through the time period, for
securities like equities the assumption seems arguable. The benefit of
this method would be having to deal with one simulation and verifying if
it represents the underlying distribution vs having several different
simulations and verifying if they accurately represent the covariance of
constituent securities. The drawback is having less flexibility in the
modeling of individual securities within the portfolio. Another drawback
is to change the weighting or portfolio members, one must recombine and
simulate the new portfolio, which could be computationally intensive
depending on the methodology.

Either way, to implement simulation, the ``_Simulation`` and
``_RandomGen`` class that handle the calculation and generation
respectfully. For example, to implement a naive return model, the
included ``NaiveMonteCarlo`` class represents the following generation
function for a single observation:

.. math::


   R_{t} = \phi

Where :math:`\phi` representing a pull from an imposed distribution. As
such, we need to specify that imposed distribution, thus we include the
``NormalDistribution _RandomGen`` class to generate a pull. This class
is just a wrapper to for numpy.random.normal with the mean and standard
deviation specified in the initialization.

Since the aim is to specify the portfolio distribution X days into the
future, we want to simulate a cumulative return path through time. Under
the assumption that each day is independent, the individual simulation
path is then:

.. math::


   P = \sum_{t=1}^{X} R_{t} = \sum_{t=1}^{X} \phi

Now to fully specify the distribution via a Monte Carlo process, we will
generate :math:`Y` paths to represent the underlying :math:`X` day
distribution. To get the mean of the distribution at each :math:`t` step
from 1 to :math:`X`:

.. math::


   E(R_{t}) = \frac{1}{Y} \sum_{i=1}^{Y} P_{t, i} + E((R_{t-1}))

To get the variance:

.. math::


   Var(R_{t}) = E\left(\left(R_{t} - E(R_{t})\right)^{2}\right) + Var(R_{t}) = \frac{1}{Y^{2}} \sum_{i=1}^{Y}\left(P_{t,i} - \bar{P_{t}} \right)

Since each return is assumed independently and identically distributed,
the above condenses to:

.. math::


   Var(R_{t}) = t \cdot Var(R_{t})

Since we can now switch out the distribution of :math:`\phi` to
represent the portfolio or constituent securities, this generation
function is agnostic of which approach explained above is taken. It’s
for that reason the design choice was made to make the ``_RandomGen``
and ``_Simulation`` classes seperate instead of building methods
directly into the ``Portfolio`` or ``_Security`` class.

Simulating a Unit Resolution Distribution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

First let’s simulate a unit resolution distribution. By default, the
resolution is one day, but depending on the market data resolution you
could simulate to match. Since the default is one day, let’s simulate a
one day distribution and then simulate a X day forward path distribution
using ``aapl_stock``:

.. code:: python

   >>> from risk_dash.simgen import NormalDistribution, NaiveMonteCarlo
   >>> log_return_generator = NormalDistribution(
       location = aapl_stock.market_data.currentexmean,
       scale = aapl_stock.market_data.currentexvol
     )

Since we’re just simulating one day, we can directly use the generator
object simulate a one day return distribution. With our new
``log_return_generator`` instance, we are assuming a normally
distributed return series. By default, using ``currentexmean`` will
center the distribution around the closest 80 day exponentially weighted
mean of daily AAPL returns. Similarly, using ``currentexvol`` will set
the standard deviation to the closest 80 day exponentially weighted
standard deviation of historic daily AAPL returns. To simulate one pull
now from a normal distribution, we have an observation that represents a
log return of AAPL.

.. code:: python

   >>> log_return_generator.generate(1)
   array([-0.00948158])

One observation isn’t really helpful for us, we now want to simulate an
arbitrarily large amount of observations to converge to the underlying
distribution. In this case, let’s simulate 5000 observations:

.. code:: python

   >>> import numpy as np
   >>> one_day_simluation = log_return_generator.generate(5000)
   >>> len(one_day_simulation)
   5000
   >>> np.mean(one_day_simluation)
   -0.00036139846164594291
   >>> aapl_stock.market_data.currentexmean
   -0.00040076765463907944
   >>>np.std(one_day_simulation)
   0.016497493178538599
   >>>aapl_stock.market_data.currentexvol
   0.016485817752205818

To parameterize the sampling distribution of the distribution, we can
simulate an arbitrarily large amount of simulations to converge to the
sampling distribution:

.. code:: python

   >>> multiple_one_day_simulations = np.array([log_return_generator.generate(5000) for i in 5000])
   >>> np.mean(np.mean(multiple_one_day_simulations, axis = 0)) # sampling distribution mean of the simulation mean
   -0.00039625427660093282
   >>> np.std(np.mean(multiple_one_day_simulations, axis=0))
   0.00023461080665209953
   >>> np.mean(np.std(multiple_one_day_simulations, axis=0))
   0.016484835778989758
   >>> np.std(np.std(multiple_one_day_simulations, axis=0))
   0.00016629650698145025

With the mean and standard deviation of the sampling distribution we can
construct confidence intervals to see if our calculated mean and
variance is contained. This would imply we have specified the imposed
distribution based on our calculation of ``currentexvol`` and
``currentexmean``. The calculation for a 95% confidence level is:

.. math::


   \bar{X} \pm Z^{*}_{p=\alpha} \frac{s}{\sqrt{n}}

So for this case, for a 95% confidence level, :math:`1-\alpha`, our
confidence interval for the simulation mean is (-0.0004027, -0.0003897)
and for the simulation standard deviation is (0.0164802, 0.0164894). Our
calculated historic values, -0.0004007 and 0.0164858, both fall within
those confidence intervals so at the 95% confidence level we can
determine this simulation represents a normally distributed one day
return series.

Simulating a Path Distribution
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

To simulate a forward return path of independent returns, we now want to
create a ``NaiveMonteCarlo`` object to simulate :math:`Y` forward
resolution paths.

.. code:: python

   >>> simulation_generator = NaiveMonteCarlo(log_return_generator)

The ``NaiveMonteCarlo`` accepts any ``_RandomGen`` object, so we could
potentially pass a ``_RandomGen`` object that might more accurately
represent our underlying data. For example, if we thought that AAPL was
distributed with a Cauchy distribution to capture fatter tails, we could
pass in a ``_RandomGen`` object that represented the distribution. Now
we’ll maintain the assumption that the log returns are normally
distributed and use the ``generator`` instance we created earlier.

To simulate 5000 paths for a 5 day forward distribution, we would then
call the ``simulate`` method passing the arguments ``periods_forward=5``
and ``number_of_simulations=5000``. This will set the
``simulation_mean``, ``simulation_std``, and ``simulated_distribution``
attributes and return the simulated distribution.

.. code:: python

   >>> path_simulation = simulation_generator.simulate(periods_forward=5, number_of_simulations=5000)
   >>> path_simulation.shape
   (5000,5)
   >>> simulation_generator.simulation_mean
   array([-0.00050452, -0.00082389, -0.00105195, -0.00135753, -0.0019303 ])
   >>> simulation_generator.simulation_std
   array([ 0.01630096,  0.02311434,  0.0283451 ,  0.03211978,  0.03607576])

The simulation distribution now is 5000 individual 5 day paths,
represented as a ``numpy`` array of shape (5000,5). The
``simulation_mean`` and ``simulation_std`` are then calculated across
the column axis, giving us the simulated generation through time. Since
this method is fairly naive, essentially the cumulative sum of
independent random normals, it makes sense that the ``simulation_mean``
vector is essentially :math:`E(R_{t}) = t \cdot E(R_{t=1})` and
:math:`S.D.(R_{t}) = \sqrt{t} * S.D.(R_{t=1})`. If we wanted to
implement a more standard approach of simulating returns, we could then
create a ``_Simulation`` class that would represent the value function.
To simulate the portfolio from the top down approach, we would then just
use the portfolio mean and variance to then simulate the portfolio.

Summary
~~~~~~~

While this is just the first introduction to the package, there are many
expandable directions to go. The aim for the package is to help
formalize the development process by providing clear template classes
and use cases. The next steps are to write ``_Security`` classes that
match the portfolio that the analyst is trying to model and
``_MarketData`` classes that match the specific data store for the
application.

.. |image1| image:: data:image/png;base64,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
